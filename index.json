{"categories":[{"link":"https://blog.dpf114.top/categories/git/","name":"Git","slug":"Git"},{"link":"https://blog.dpf114.top/categories/http%E5%8D%8F%E8%AE%AE/","name":"HTTP协议","slug":"HTTP协议"},{"link":"https://blog.dpf114.top/categories/linux/","name":"Linux","slug":"Linux"},{"link":"https://blog.dpf114.top/categories/nginx/","name":"Nginx","slug":"Nginx"},{"link":"https://blog.dpf114.top/categories/python/","name":"Python","slug":"Python"},{"link":"https://blog.dpf114.top/categories/ssm/","name":"SSM","slug":"SSM"},{"link":"https://blog.dpf114.top/categories/%E7%BD%91%E7%BB%9C/","name":"网络","slug":"网络"}],"pages":[],"posts":[{"link":"https://blog.dpf114.top/posts/linux-often/","text":"Linux常用命令 1.连接 1  ssh root@ip   2.文件上传下载 windows中使用xshell(强烈推荐)或者FinalShell，Mac也可以使用FinalShell。\n或者使用命令：\n文件上传：\n1  scp 本地文件路径 用户名@ip地址:服务器要存放的的路径   例如将文件/Users/dpf/Desktop/1.txt上传到服务器122.51.114.41的根目录\n1  scp /Users/dpf/Desktop/1.txt root@122.51.114.41:/   文件下载：\n1  scp 用户名@IP地址:需要下载的文件路径 本地存放下载的路径   例如将122.51.114.41根目录的文件下载到本地Users路径下\n1  scp root@122.51.114.41:/1.txt /Users   3.端口号相关 1.列出所有已经使用的端口号\n1  netstat -ntlp   2.查看某个端口号占用情况\n1 2  lsof -i:端口号 netstat -lnpt |grep 端口号   若-bash: lsof: 未找到命令，通过命令安装yum install lsof\n3.关闭已经占用的端口号\n1  kill -9 pid   上面第2点可以查看端口号对应pid\n4.防火墙相关 Centos6.x\n1 2 3 4 5 6  service iptables start service iptables restart /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT -- 开启指定端口 /etc/init.d/iptables save -- 保存修改 /sbin/iptables -I INPUT -p tcp --dport 8080 -j DROP -- 关闭指定端口   Centos7.x\n1 2 3 4 5 6 7 8  systemctl start firewalld：开启防火墙 systemctl status firewalld systemctl stop firewalld firewall-cmd --add-port=8080/tcp --permanent：开放8080端口 firewall-cmd --reload：重新加载(修改端口号后需要重新加载) firewall-cmd --query-port=123/tcp：查询指定端口是否开启成功 firewall-cmd --permanent --remove-port=123/tcp：关闭指定端口 firewall-cmd --zone=public --list-ports:查看开放的所有端口   5.网络相关 查看本机公网信息\n1  curl cip.cc   请求web服务器(多用于查看某个应用是否部署成功)\n1 2  curl ip curl http://127.0.0.1:8080   查看网络情况\n1  ifconfig   测试网络是否连通\n1  ping ip地址或域名   6.文件相关 创建文件\n1 2 3 4  mkdir 目录 -p 创建目录，若无父目录，则创建p(parent) touch 创建空文件   编辑文件\n1 2 3 4 5 6  vim / vi 文件名 insert 编辑 :q 退出 :q! 强制退出 :wq 保存并退出 esc 退出编辑   复制文件\n1 2 3  cp 需要复制的文件 需要复制到的目录[新名字] cp 1.txt /home/2.txt cp 1.txt 2.txt   删除文件\n1 2 3  rm 文件名 -r 递归删除，可删除子目录及文件 -f 强制删除   移动文件\n1  mv 文件 目标目录   解压文件\n .zip unzip xxx.zip .xz xz -d xxx.tar.xz .tar tar -xvf xxx.tar .tar.gz tar -zxvf xxx.tar.gz  查看文件内容\n1 2 3  cat 文件名 echo \u0026#39;\u0026#39; -- 输出字符串 echo “$JAVA_HOME” -- 查看环境变量内容   查看日志\n1 2 3 4 5  head log.txt\t-- 查看日志前10行 tail log.txt\t-- 查看日志后10行 head -n 5 log.txt -- 查看日志前5行 tail -n 5 log.txt\t-- 查看日志后5行 tail -f log.txt\t-- 实时查看日志   7.其他命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  cd 目录\t--切换目录 ls -l -- 显示当前路径下所有的文件 su -- 切换用户 sudo -- 以管理员身份运行 chmod\t-- 修改文件或目录权限 kill -- 杀进程 pwd\t-- 显示当前目录 date\t-- 显示当前时间 who -- 显示在线登陆用户 whiami\t-- 显示当前操作用户 hostname\t-- 显示主机名 uname\t-- 显示系统信息 clear\t-- 清屏 reboot\t-- 重启系统 shutdown -r 关机重启 -h 关机不重启 now 立刻关机 whereis\t-- 查看某文件位置 top\t-- 动态显示当前耗费资源最多进程信息   常用软件安装与配置 1.MySQL https://blog.csdn.net/qq_41262903/article/details/109151734\n2.Redis https://blog.csdn.net/qq_41262903/article/details/104190716\n3.Nginx https://blog.csdn.net/qq_41262903/article/details/106072890\n4.JDK 本地安装：https://blog.csdn.net/qq_41262903/article/details/102649149\n在线安装：https://blog.csdn.net/qq_41262903/article/details/101446348\n","title":"自用Linux常用命令"},{"link":"https://blog.dpf114.top/posts/git-often-used/","text":"1.什么版本控制系统 单独的讲版本控制我们或许不知道它是什么，但是举个我们生活中的小例子，我们很容易明白它是什么。\n例如我们毕业修改无数遍的论文：\n1 2 3 4 5 6 7 8 9 10 11  毕业论文最终版 毕业论文最最终版 毕业论文最最最终版 毕业论文最最最最终版 毕业论文最终不改版 毕业论文最终真不改版 毕业论文最终真真不改版 毕业论文最终打死不改版 毕业论文最终打死不改版 2 ...   这里有很多版本，而版本控制系统就是对我们写的内容不同版本进行控制的系统。\n常用的版本控制系统有SVN和Git。我们在实际开发中Git使用的比较多。\n2.安装和配置 2.1.安装 Windows\n对于windows只要下载安装包直接安装即可。\nLinux\n使用apt-get工具下载安装\n1 2  apt-get update sudo apt-get install git   Mac\n使用brew工具下载安装\n1  brew install git   2.2.安装后配置 不管是 Windows 安装还是 Linux 安装，安装好之后，我们都先通过如下两行命令做一个基本配置,目的是为了区分不同开发人员的身份，即每次提交都是由谁提交的。配置方式如下：\n1 2  git config --global user.name \u0026#39;username\u0026#39; git config --global user.email \u0026#39;username@qq.com\u0026#39;   配置完成后配置信息存储在~/.gitconfig文件中\n3.基本使用 在基本操作之前我们要了解一下Git使用的分区\n 工作区：工作区也就是我们平常写代码的地方 暂存区：通过git add提交后临时存放代码的地方 本地库：通过git commit提交后存放代码的地方，本地库保存着历史版本相关信息。 远程库：远程库也就是远程代码仓库，例如Gitee、GitHub、gitlab。  3.1.初始化仓库 初始化仓库有两种方式，一种是通过从远程仓库克隆，另外一种是直接从当前目录初始化，命令如下：\n1  git init   执行完成后当前目录下会多出一个 .git 的隐藏文件夹，所有 git 需要的数据和资源都存放在该目录中。\n3.2.查看仓库状态 通过git status命令可以查看仓库的状态。刚初始化的仓库查看状态如下：\n修改工作区后查看状态如下图：\n提交暂存区后查看状态如下图：\n提交到本地仓库后查看状态如下图：\n3.3.提交到暂存区 通过git add可以将工作区的内容提交到暂存区，有以下几种使用情况：\n1 2 3  git add 具体文件 git add . git add *   .和*都代表提交工作区的所有文件。\n3.4.提交到本地库 通过git commit将暂存区内容提交到本地仓库，具体使用如下：\n1  git commit -m \u0026#39;提交描述内容\u0026#39;    注意：描述内容不能为空。建议每次提交写清楚提交内容，可用于版本回退。\n 3.5.提交到远程仓库 如果是通过克隆的方式初始化仓库，提交到本地库后，可以直接通过git push直接提交到远程仓库，如果是通过git init初始化，需要远程远程创建好对应仓库后，让本地仓库跟远程仓库关联，让后再用  git push提交。\n关联远程仓库\n用git remote命令关联远程仓库，格式git remote add 别名 远程仓库url,举例如下\n1  git remote add origin https://github.com/xiaoxiaoshou/testgit.git   这里的url你可能两种类型，分别为https://github.com/username/reponame.git和git@github.com:username/reponame.github.io.git,代表着git两种不同的连接方式。\n其他关联远程仓库相关命令：\n1 2 3 4  # 查看关联了哪些远程分支 git remote -v # 删除关联分支 git remote remove 别名   提交到远程仓库\n提交命令格式git push 别名 分支名，举例如下:\n1  git push origin master   3.6.从远程拉取代码 常用有以下两种方式：\n1.使用git clone\n默认从远程master分支拉取：\n1  git clone 远程url地址   指定分支拉取：\n1  git clone -b 分支名称 远程url地址   使用git pull\n使用格式git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;。\n例如我们要将远程 origin 的 master 分支拉取过来，与本地的 master 分支合并\n1  git pull origin master:master   我们也可以简化为\n1 2 3  git pull origin master git pull origin git pull    git pull = git fetch+git merge,fetch的作用是从远程拉取代码，merge的作用是合并代码(后面分支管理有详细解析)\n 4.代码撤销与版本回退 4.1.查看提交记录 使用git log可以查看提交过的信息，每次提交（git commit）到本地仓库的详细信息，每条提交信息大致如下：\n1 2 3 4 5  commit cdc2ac8c3b6d9f8bde05140aca484aa4482f8895 Author: xiaoxiaoshou \u0026lt;446933040@qq.com\u0026gt; Date: Tue Dec 1 15:41:13 2020 +0800 提交描述内容   commit后面的编号是每次提交的一个索引（我们可以叫它版本号），用于版本前进或后退\n使用git log显示的内容过多，我们一般使用下面两个比较简洁的查看方式：\n1 2 3 4  # 推荐使用 git reflog git log --online   4.2.工作区代码撤销 可能有一天你正在写代码，写了很久发现写错了，想恢复到一开始的状态，一个笨办法就是把刚刚写的代码一行一行的删除，不过这种方式成本太高，可以通过 git checkout -- \u0026lt;file\u0026gt; 命令来撤销工作区的代码修改。如下图：\n4.3. 添加到暂存区代码撤销 想要撤销提交到暂存区的代码分以下两步：\n  1.将暂存区代码撤销到工作区git reset HEAD\n  2.将工作区代码撤销（和工作区代码撤销一样）git checkout -- file\n  4.4.提交到本地仓库代码版本回退 基于索引版本回退（推荐使用）\n1.查看提交历史\n2.使用git reset --hard [局部索引值]回退（可前进和后退）\n使用^符号\n1  git reset --hard^    一个^回退一步\n 使用~符号\n1  git reset --hard~n\t   n代表后退步数\n git reset 中三个参数比较\n1 2 3  git reset --soft git reset --mixed git reset --hard    \u0026ndash;soft  仅仅在本地库移动 HEAD 指针   \u0026ndash;mixed  在本地仓库移动HEAD指针 重置暂存区   \u0026ndash;hard  在本地库移动 HEAD 指针 重置暂存区 重置工作区    4.5.提交到远程仓库版本回退 由于远程仓库与本地仓库内容一致，所以需要远程仓库版本回退只需要本地版本回退再提交到远程仓库即可。\n5.分支管理 5.1. 什么是分支 我们在完成一个项目时，不可能是“单线程”开发的，很多时候任务是并行的。举个栗子：项目 2.0 版本上线了，现在要着手开发 3.0 版本，同时 2.0 版本可能还有一些 bug 需要修复，这些 bug 修复之后我们可能还会发 2.1，2.2，2.3 这些版本，我们不可能等所有 bug 都修复完了再去开发 3.0 版本，修复 2.0 的 bug 和开发 3.0 的新功能是两个并行的任务，这个时候我们 3.0 的功能开发直接在 master 分支上进行肯定不合适，我们要保证有一个稳定，可以随时发版本的分支存在（一般情况下这个角色由 master 分支来扮演），此时我们就可以灵活的使用 Git 中的分支管理功能：\n 创建一个长期分支用来开发 3.0 功能，假设这个分支的名字就叫 v3，我们在 v3 上添加新功能，并不断测试，当 v3 稳定后，将 v3 合并到 master 分支上。 创建一个特性分支用来修复 2.0 的 bug ，一旦 bug 修复成功，就将该分支合并到 master 上，一旦发现新 bug ，就立马再创建分支进行修复，修复成功之后再合并。  5.2.查看分支 我们可以使用命令git branch来查看当前仓库有哪些分支和我们当前所处的分支\n前面带*的分支为我们当前所处分支。\n5.3.创建并切换分支 第一种方法\n 先用git branch 分支名创建分支 然后再用git checkout 分支名切换分支  第二种方法\n使用git checkout -b 分支名创建和切换分支一步到位。\n5.4.整合分支 分支的整合有两种形式，一种是merge,另外一种是rebase\nmerge\n使用命令git merge [有新内容的分支名]合并分支。\n上图解释：主分支在m1时发现有bug，于是切出一个分支bugFix，经过一段时间，主分支开发到m3，bugFix分支(已提交为m2)bug已经解决，这时候需要将bugFix分支合到主分支即使用命令git merge bugFix。\nrebase\nrebase 又叫变基，使用命令git rebase [有新内容的分支]可以变基。\n上图解析：上图是在主分支使用命令git rebase bugFix进行整合分支，整合过程是将bugFix的提交记录在主分支自底向上再提交一遍。\nmerge和rebase的区别\n  merge是把当前分支和要合并的分支合并在一起，进行一次commit提交\n  rebase是把要rebase分支的历史提交在当前分支按顺序重新提交，rebase之后HEAD的位置不变(也就是图中的*)\n  rebase过程中可能产生冲突，解决冲突后继续提交\n 解决冲突 提交到缓冲区git add . 继续完成合并git rebase --continue  以下是冲突部分内容\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\r需要合并分支的内容\r=======\r当前分支内容\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;   6.标签管理 我们可以给某一个提交打上一个标签，以示重要。比较有代表性的打标签用它来发布对应的应用的版本比如v1.0、v2.0。Git支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n我们可以用以下命令查看仓库中所有标签：\n1  git tag   6.1.轻量标签 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。\n轻量标签打标签格式git tag 标签名称，举例如下：\n1  git tag v0.0   轻量标签默认是对最新的commit进行。\n我们也可以对指定commit进行打标签，格式git tag 标签名称 commi对应索引。举例如下\n1 2 3 4  # 查看commit索引 git reflog # 打标签 git tag v0.01 bcde256   我们也可以删除掉本地仓库上的标签，格式git tag -d 标签名称，举例：\n1  git tag -d v0.01   6.2.附注标签 附注标签是存储在仓库中一个完整对象，它有自己的校验和信息，其中包含标签者的名字、电子邮件、日期时间，此外还有一个标签信息。可以使用 GNU Privacy Guard （GPG) 签名并验证。\n打附注标签格式 git tag -a 标签名称 -m '标签信息',举例如下：\n1  git tag -a v1.0 -m \u0026#39;my version 1.0\u0026#39;   6.3.将标签推送到远程仓库 默认情况下，git push 命令并不会传送标签到远程仓库。需要我们手动将标签推送到远程仓库，推送格式git push 远程分支别名 标签名，举例：\n1  git push origin v1.0   \r参考资料：\nhttps://git-scm.com/book/zh/v2\nhttps://www.runoob.com/git/git-tutorial.html\nhttps://segmentfault.com/a/1190000037465780\n边学习边玩会游戏：https://learngitbranching.js.org/?locale=zh_CN\n","title":"Git非官方使用总结"},{"link":"https://blog.dpf114.top/posts/nginx-config/","text":"1.Nginx是什么 Nginx是一个高性能的Web和反向代理服务器。作为web服务器它与我们常用的web应用服务器（tomcat、jetty）不同的是：它不能解析jsp等页面，只能解析html、css、JavaScript；作为反向代理服务器它在我们应用部署时应用广泛，例如静态页面的部署、反向代理等。\n2.安装 Windows 下载，解压即可立即使用。\nLinux 看这篇教程\nMac Mac可以跟Linux一样安装，也可以用下面方法安装：\n查询是否已经安装和对应信息\nbrew info nginx\r安装\nbrew install nginx\r 安装已经配置好环境变量可以直接启动\n 启动\nnginx 配置文件\nvim /usr/local/etc/nginx/nginx.conf\r3.配置文件详解 例如Linux安装好之后，我们在/usr/local/nginx/conf/有一个文件名为nginx.conf的配置文件。配置文件默认内容如下（已经加上注释）：\n给配置文件加上注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144  #user nobody; # 启动进程，通常设置成和cpu的数量相等 worker_processes 1; # 全局错误日志 #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; # PID文件 #pid logs/nginx.pid; # 工作模式及连接数上限 events { # 支持最大连接数 worker_connections 1024; } http { #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; # 日志格式  #log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; # \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; # \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; #access_log logs/access.log main; # 指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件 sendfile on; #防止网络阻塞 #tcp_nopush on; # 连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; # 开启zip压缩 #gzip on; # 虚拟主机配置，一个http中可以包含多个server server { # 监听端口 listen 8080; # 请求地址（可以是域名或IP地址），多个地址之间用空格隔开 server_name localhost; # 编码, 如果网页格式与当前配置的不同的话将会被自动转码 #charset koi8-r; #虚拟主机访问日志定义  #access_log logs/host.access.log main; # location对指定路径进行拦截处理（默认路径）  location / { # 首页应用路径 root html; # 首页对应root下的哪个文件 index index.html index.htm; } # 错误信息页面 #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # 代理配置例子：访问URL以.php结尾则自动转交给127.0.0.1 # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # 转发(类似代理Proxy)： php脚本请求全部代理给FastCGI处理 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # 配置禁止访问 .htxxx文件 # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} include servers/*; }   4.常用配置 4.1.反向代理 在进行配置前先了解几个概念：代理服务器、正向代理、反向代理。\n代理服务器\n所谓代理服务器就是位于发起请求的客户端与原始服务器端之间的一台跳板服务器，正向代理可以隐藏客户端，反向代理可以隐藏原始服务器。\n正向代理\n用户知道目标服务器地址，但由于网络限制等原因，无法直接访问。这时候需要先连接代理服务器，然后再由代理服务器访问目标服务器。正向代理目标服务器不知道真实的客户端。\n反向代理\n用户知道代理服务器地址，但是代理服务器不是最终处理用户请求的服务器，代理服务器通过用户的请求地址将请求交给不同的最终服务器处理。反向向代理用户不知道真实服务器的地址。\n配置举例\n例子1：我们将来自于www.123.com的请求全部反向代理给http://127.0.0.1:8080处理。\n1 2 3 4 5 6 7 8  server { listen 80; server_name www.123.com; location / { proxy_pass http://127.0.0.1:8080; } }   例子2：根据访问的路径将请求交给不同的服务处理。\n访问 http://127.0.0.1/edu/ 请求交给http://127.0.0.1:8081处理\n访问 http://127.0.0.1/vod/ 请求交给http://127.0.0.1:8082处理\n1 2 3 4 5 6 7 8 9 10 11 12  server { listen 80; server_name www.123.com; location ~ /edu/ { proxy_pass http://127.0.0.1:8081; } location ~ /vod/ { proxy_pass http://127.0.0.1:8082; } }   location说明\nlocation用于请求路径的匹配。语法如下：\n1 2 3  location [= | ~ | ~* | ^~] url { }    = 用于不含正则表达式的URL的精确匹配。 ~用于表示URL包含正则表达式的匹配，区分大小写。 ~*用于表示URL包含正则表达式的匹配，不区分大小写。 ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录   如果URI包含正则表达式，必须包含~或者~*标识\n 4.2 负载均衡 什么是负载均衡？ 负载均衡从字面意思理解将自己承受不了的压力分摊给别人处理共同承受压力。在我们部署环境中意思为将请求分发给多台服务器进行处理，使服务器能够承受更大的并发。\n配置举例 将来自http://127.0.0.1/edu/1.html的访问实现负载均衡效果，平均分配给8080和8081端口处理。\n准备两个Tomcat(修改端口号准备好1.html文件)分别启动。\nnginx配置:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  http{ upstream myserver{ server 127.0.0.1:8080; server 127.0.0.1:8081; } server{ listen\t80; server_name localhost; } location / { proxy_pass\thttp://myserver; root\thtml; index\tindex.html\tindex.htm; } }    myserver为自己取得名称，可以随意取。\n Nginx实现负载均衡的几种策略 1.轮询（默认策略）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n2.weight\nweight代表权重，默认为1，权重越大被分配的客户端越多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  http{ upstream myserver{ server 127.0.0.1:8080\tweight=10; server 127.0.0.1:8081\tweight=5; } server{ listen\t80; server_name localhost; } location / { proxy_pass\thttp://myserver; root\thtml; index\tindex.html\tindex.htm; } }   3.ip_hash\n每个请求按ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决Session问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  http{ upstream myserver{ ip_hash; server 127.0.0.1:8080; server 127.0.0.1:8081; } server{ listen\t80; server_name localhost; } location / { proxy_pass\thttp://myserver; root\thtml; index\tindex.html\tindex.htm; } }   4.fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  http{ upstream myserver{ server 127.0.0.1:8080; server 127.0.0.1:8081; fair; } server{ listen\t80; server_name localhost; } location / { proxy_pass\thttp://myserver; root\thtml; index\tindex.html\tindex.htm; } }   4.3 动静分离 什么是动静分离？ Nginx 动静分离简单来说就是把动态资源跟静态资源请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开（通过 location 指定不同的后缀名实现不同的请求转发，通过expires配置静态资源缓存时间）；目的是提高网站响应速度，减轻服务器的负担。\n从目前的实现角度来说大致有两种：\n 一种是把静态文件放在单独的服务器上，这是目前主流的方法； 一种就是动态文件和动态文件混合在一起发布，通过nginx配置分开。  举例 我们开发的一个应用，部署时静态资源存储的宿主机的data目录下，后台接口都是以/api/为前缀，当发来动态请求时由location拦截反向代理给http://192.168.122.128:8080处理。当发来静态资源请求时，从宿主机获取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  http{ server{ listen\t80; server_name localhost; } location /api/ { proxy_pass\thttp://192.168.122.128:8080; } # 文件浏览器配置 # location / { # root\t/; # autoindex\ton; #目录索引页 # } location ~ .*\\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ { root /data/; #宿主机静态资源目录 也可以反向代理到静态资源服务器获取 expires 3d; # 缓存3天  } }   4.4 高可用集群  注意：本案例只是虚拟机内网测试，不适用于公网测试。\n 什么是高可用集群？ 高可用(High Availability)简称HA，即通过设计减少系统不能提供服务的时间(即宕机后最短时间内提供服务)，集群是多台机器一起工作。通俗的讲：高可用集群就是宕机了能在短时间内继续提供服务的一个多台机器组成的系统。\nNginx配置高可用集群有两种配置方案\n  keepalived+nginx 主从配置\n这种方案，使用一个vip（虚拟IP）地址，2台服务器，一台做主，一台做备，但同时只有一台机器工作，另一台备份机器在主机器不出现故障的时候，永远处于浪费状态，对于服务器不多的网站，该方案不经济实惠。\n  keepalived+nginx 双主配置\n这种方案，使用两个vip地址，2台服务器，互为主备，同时有两台机器工作，当其中一台机器出现故障，两台机器的请求转移到一台机器负担。\n  环境准备 准备两台服务器（这里以CentOs 7.X为例）。\n 这里只是举例Nginx配置，没有其他的反向代理配置（tomcat等服务器）。\n 1.安装Nginx 建议看这篇文章 2.安装Keepalived 1  yum install keepalived –y   安装之后在/etc/目录下多个一个keepalived目录，keepalived目录下的keepalived.conf为其配置文件。\n Keepalived的作用为激活虚拟IP，使客户端能够通过虚拟IP访问到对应服务。\n 3.编写nginx检测脚本（两台机器） vim /etc/keepalived/nginx_check.sh。\n1 2 3 4 5 6 7 8 9 10  #!/bin/bash A=`ps -C nginx --no-header | wc -l` if [ $A -eq 0 ];then /www/server/nginx/sbin #尝试重新启动nginx sleep 2 #睡眠2秒 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived #启动失败，将keepalived服务杀死。将vip漂移到其它备份节点 fi fi   添加可执行权限chmod +x /etc/keepalived/nginx_check.sh\n主从配置 主机keepalived配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  global_defs { # 收件人 #\tnotification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # 发件人 # notification_email_from Alexandre.Cassen@firewall.loc # 发邮件服务器 #\tsmtp_server 192.168.200.1 # 超时时间 # smtp_connect_timeout 30 router_id LVS_DEVEL01 # 局域网keppalived主机身份标识信息(每台唯一) } # 集群资源监控，组合track_script进行  vrrp_script chk_nginx { script \u0026#34;/etc/keepalived/nginx_check.sh\u0026#34; interval 2 #每2秒检测一次nginx的运行状态 weight -20 #失败一次，将自己的优先级-20 } vrrp_instance VI_1 { state MASTER # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.50 // VRRP H 虚拟地址 } }   备用机keepalived配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  global_defs { # 收件人 #\tnotification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # 发件人 # notification_email_from Alexandre.Cassen@firewall.loc # 发邮件服务器 #\tsmtp_server 192.168.200.1 # 超时时间 # smtp_connect_timeout 30 router_id LVS_DEVEL02 # 局域网keppalived主机身份标识信息(每台唯一) } # 集群资源监控，组合track_script进行  vrrp_script chk_nginx { script \u0026#34;/etc/keepalived/nginx_check.sh\u0026#34; interval 2 #每2秒检测一次nginx的运行状态 weight -20 #失败一次，将自己的优先级-20 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.50 // VRRP H 虚拟地址 } }   测试：\n启动两台机器的nginx和keepalived服务\n启动nginx：\n1  nginx   启动keepalived\n1  systemctl start keepalived.service   查看keepalived是否启动\n1  ps -ef | grep keepalived   查看主机虚拟IP绑定情况\n1  ip addr   通过虚拟IP访问\n模拟主机nginx宕机（杀掉keepalived服务，杀掉nginx是不行的,因为keepalived对应检测脚本检测到Nginx死了会尝试重启）\n1  systemctl stop keepalived.service   这时候通过虚拟IP访问可以看到已经切换到从机\n双主配置 第一台机器:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  global_defs { # 收件人 #\tnotification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # 发件人 # notification_email_from Alexandre.Cassen@firewall.loc # 发邮件服务器 #\tsmtp_server 192.168.200.1 # 超时时间 # smtp_connect_timeout 30 router_id LVS_DEVEL01 # 局域网keppalived主机身份标识信息(每台唯一) } # 集群资源监控，组合track_script进行  vrrp_script chk_nginx { script \u0026#34;/etc/keepalived/nginx_check.sh\u0026#34; interval 2 #每2秒检测一次nginx的运行状态 weight -20 #失败一次，将自己的优先级-20 } vrrp_instance VI_1 { state MASTER # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.50 // VRRP H 虚拟地址 } } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 52 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.51 // VRRP H 虚拟地址 } }   第二台机器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  global_defs { # 收件人 #\tnotification_email { # acassen@firewall.loc # failover@firewall.loc # sysadmin@firewall.loc # } # 发件人 # notification_email_from Alexandre.Cassen@firewall.loc # 发邮件服务器 #\tsmtp_server 192.168.200.1 # 超时时间 # smtp_connect_timeout 30 router_id LVS_DEVEL02 # 局域网keppalived主机身份标识信息(每台唯一) } # 集群资源监控，组合track_script进行  vrrp_script chk_nginx { script \u0026#34;/etc/keepalived/nginx_check.sh\u0026#34; interval 2 #每2秒检测一次nginx的运行状态 weight -20 #失败一次，将自己的优先级-20 } vrrp_instance VI_1 { state BACKUP # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 51 # 主、备机的 virtual_router_id 必须相同 priority 90 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.50 // VRRP H 虚拟地址 } } vrrp_instance VI_2 { state MASTER # 备份服务器上将 MASTER 改为 BACKUP  interface eth0 # 网卡 virtual_router_id 52 # 主、备机的 virtual_router_id 必须相同 priority 100 # 主、备机取不同的优先级，主机值较大，备份机值较小 advert_int 1 # 设置高可用集群中不抢占功能，在主机down后，从机接管，当主机重新恢复后，主机不抢占备用机 #\tnopreempt  authentication { auth_type PASS auth_pass 1111 } # 集群资源监控，组合vrrp_script进行  track_script { chk_nginx }\tvirtual_ipaddress { 10.211.55.51 // VRRP H 虚拟地址 } }   测试：\n重新启动两台机器的keepalived服务\n1  systemctl restart keepalived.service   在两台机器上都可以通过ip addr看到绑定的对应虚拟IP地址\n通过虚拟IP访问：\n当一台服务的nginx挂掉之后两个虚拟IP访问都会到同一台机器。\n","title":"Nginx常用配置（反向代理、负载均衡、动静分离、高可用集群）"},{"link":"https://blog.dpf114.top/posts/%E4%B8%8Ehttp%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%84%E4%BB%B6/","text":"网络模型 网络是一个复杂的系统，不仅包括大量的应用程序、端系统、通信链路、分组交换机等，还有各种各样的协议组成，那么现在我们就来聊一下网络中的协议层次。\n为了给网络协议的设计提供一个结构，网络设计者以分层(layer)的方式组织协议，每个协议属于层次模型之一。每一层都是向它的上一层提供服务(service)，即所谓的服务模型(service model)。每个分层中所有的协议称为 协议栈(protocol stack)。因特网的协议栈由五个部分组成：物理层、链路层、网络层、运输层和应用层。我们采用自上而下的方法研究其原理，也就是应用层 -\u0026gt; 物理层的方式。\n应用层 应用层是网络应用程序和网络协议存放的分层，因特网的应用层包括许多协议，例如我们学 web 离不开的 HTTP，电子邮件传送协议 SMTP、端系统文件上传协议 FTP、还有为我们进行域名解析的 DNS 协议。应用层协议分布在多个端系统上，一个端系统应用程序与另外一个端系统应用程序交换信息分组，我们把位于应用层的信息分组称为 报文(message)。\n运输层 因特网的运输层在应用程序断点之间传送应用程序报文，在这一层主要有两种传输协议 TCP 和 UDP，利用这两者中的任何一个都能够传输报文，不过这两种协议有巨大的不同。\nTCP 向它的应用程序提供了面向连接的服务，它能够控制并确认报文是否到达，并提供了拥塞机制来控制网络传输，因此当网络拥塞时，会抑制其传输速率。\nUDP 协议向它的应用程序提供了无连接服务。它不具备可靠性的特征，没有流量控制，也没有拥塞控制。我们把运输层的分组称为 报文段(segment)\n网络层 因特网的网络层负责将称为 数据报(datagram) 的网络分层从一台主机移动到另一台主机。网络层一个非常重要的协议是 IP 协议，所有具有网络层的因特网组件都必须运行 IP 协议，IP 协议是一种网际协议，除了 IP 协议外，网络层还包括一些其他网际协议和路由选择协议，一般把网络层就称为 IP 层，由此可知 IP 协议的重要性。\n链路层 现在我们有应用程序通信的协议，有了给应用程序提供运输的协议，还有了用于约定发送位置的 IP 协议，那么如何才能真正的发送数据呢？为了将分组从一个节点（主机或路由器）运输到另一个节点，网络层必须依靠链路层提供服务。链路层的例子包括以太网、WiFi 和电缆接入的 DOCSIS 协议，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为 帧(frame)\n物理层 虽然链路层的作用是将帧从一个端系统运输到另一个端系统，而物理层的作用是将帧中的一个个 比特 从一个节点运输到另一个节点，物理层的协议仍然使用链路层协议，这些协议与实际的物理传输介质有关，例如，以太网有很多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤等等。\n五层网络协议的示意图如下\n2.OSI模型 我们上面讨论的计算网络协议模型不是唯一的 协议栈，ISO（国际标准化组织）提出来计算机网络应该按照7层来组织，那么7层网络协议栈与5层的区别在哪里？\n从图中可以一眼看出，OSI 要比上面的网络模型多了 表示层 和 会话层，其他层基本一致。表示层主要包括数据压缩和数据加密以及数据描述，数据描述使得应用程序不必担心计算机内部存储格式的问题，而会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案。\n 除了网络模型五层、OSI模型7层、还有一个TCP/IP 4层\n 3.浏览器 浏览器是使用HTTP的主要载体，浏览器的名字叫做Web Broser，顾名思义，就是检索、检查互联网上网页资源的应用程序，名字里的Web，实际上指的就是World Wide Web,也就是万维网。\n当我们在浏览器地址栏输入URL(即网址)，浏览器会向DNS提供网址，DNS完成URL到IP地址的映射。然后将请求提交给具体的服务器，再由服务器返回我们想要的结果给浏览器，最后浏览器完成对结果的渲染，就有了我们在浏览器看的的东西。\n4.Web服务器 Web 服务器的正式名称叫做Web Server，Web服务器一般指的就是网站服务器，上面说的浏览器是HTTP请求的发起方，那么Web服务器就是HTTP请求的应答方，Web服务器可以向浏览器等Web客户端提供文档，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载。目前最主要的Web服务器时Apache、Nginx、IIS。\n5.CDN CDN的全称是Content Delivery Network，即内容分发网络，它应用了HTTP协议里的缓存和代理技术，代替源站响应客户端请求。CDN是构建在现有网络基础之上的网络，它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户获取所需的内容，降低网络阻塞，提高用户访问响应速度和命中率。\n打个比方说你要去亚马逊买书，之前你只能通过购物网站购买后从美国发货过海关等重重关卡送到你的家里，现在在中国建立一个亚马逊分基地，你就不用通过美国进行邮寄，从中国就能把书尽快的给你送到。\n6.WAF WAF是一种Web应用程序防护系统（Web Application Firewall，简称WAF）,它是一种通过执行针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。它是应用层面的防火墙，专门检测HTTP流量，是防护Web应用的安全技术。\nWAF通常位于Web服务器之前，可以组织如SQL注入、跨站脚本等攻击。\n7.WebService WebService 是一种 Web 应用程序，WebService是一种跨编程语言和跨操作系统平台的远程调用技术。\nWeb Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。\n8.HTML HTML 称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的 Internet 资源连接为一个逻辑整体。HTML 文本是由 HTML 命令组成的描述性文本，HTML 命令可以说明文字，图形、动画、声音、表格、链接等。\n9.Web 页面构成 Web 页面（Web page）也叫做文档，是由一个个对象组成的。一个对象(Objecy) 只是一个文件，比如一个 HTML 文件、一个 JPEG 图形、一个 Java 小程序或一个视频片段，它们在网络中可以通过 URL 地址寻址。多数的 Web 页面含有一个 HTML 基本文件 以及几个引用对象。\n举个例子，如果一个 Web 页面包含 HTML 文件和5个 JPEG 图形，那么这个 Web 页面就有6个对象：一个 HTML 文件和5个 JPEG 图形。HTML 基本文件通过 URL 地址引用页面中的其他对象。\n","title":"与HTTP相关的组件"},{"link":"https://blog.dpf114.top/posts/cookie%E5%92%8Csession/","text":"HTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session和Cookie的主要目的就是为了弥补HTTP的无状态特性。\nf 1.Session 是什么？ 客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是Session对象。Session弥补了HTTP无状态特性，服务器可以利用Session存储客户端在同一个会话期间的一些操作记录。\n2.Session如何判断是否是同一会话 服务器第一次接收到请求时，开辟了一块Session空间（创建了Session对象），同时生成一个sessionId，并通过响应头Set-Cookie：JSESIONID=XXXXXXX命令，向客户端发送要求设置Cookie的响应；客户端收到响应后，在本机客户端设置了一个JSESIONID=XXXXXXX的Cookie信息，该Cookie的过期时间为浏览器会话结束；\n接下来客户端每次向同一个网站发送请求时，请求头都会带上Cookie信息（包含cookieId）,然后服务器通过读取请求头中的Cookie信息，获取名称为JSESSIONID的值，得到此次请求的sessionId。\n3.Session 的缺点 分布式程序部署的情况下，多个服务之间Session不能共享。通常解决办法为存储的数据库(Redis里)或者用jwt。\n4. Cookie 是什么？ HTTP协议中的Cookie包括Web Cookie和浏览器Cookie，它是服务器发送到Web浏览器的一小块数据。服务器发送到浏览器的Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。\nCookie主要用于下面三个目的：\n  会话管理\n登录、购物车、游戏得分或者服务器应该记住的其他内容\n  个性化\n用户偏好、主题或者其他设置\n  追踪\n记录分析用户行为\n  Cookie曾经用于一般的客户端存储。虽然这是合法的，因为它们是在客户端存储数据的唯一办法，但如今建议使用现代存储API。Cookie随每个请求异同发送，因此它们可能会降低性能。\n5.创建Cookie 当接收到客户端发出的HTTP请求时，服务器会发送带有响应的Set-Cookie标头，Cookie通常由浏览器存储，然后将Cookie与HTTP标头一同向服务器发出请求。\nSet-Cookie和Cookie标头 Set-CookieHTTP响应标头将cookie从服务器发送到用户代理。下面是一个发送Cookie的例子\n此标头告诉客户端存储Cookie。\n客户端存储Cookie之后，客户端每次发送新请求，浏览器将使用Cookie头将以前存储的Cookie发送回服务器。\n有两种类型的Cookies（Cookies与Cookie无区别，为了协助完整辨认使用者在浏览器我叫Cookies），一种是Session Cookies(临时Cookies)，一种是Persistent Cookies(永久性Cookies)，如果Cookie到期日期，则将其视为会话Cookie。会话Cookie存储在内存中，永远不会写入磁盘，当浏览器关闭后Cookie将永久丢失。如果Cookie包含有效期，则将其视为持久性Cookie，在到期指定日期，Cookie将从磁盘中删除。\n还有一种是Cookie的Secure和HttpOnly标记，下面依次介绍\n会话Cookies 上面实例穿件的是会话Cookie，会话Cookie有个特征，客户端关闭时Cookie会删除，因为他没有指定Expires或Max-Age指令。\n但是，Web浏览器可能会使用会话还原，这回使大多数会话保持永久状态，就想从未关闭过浏览器一样。\n永久性Cookies 永久性Cookie不会再客户端关闭时期关闭，而是在特定日期（Expire是）或特定时间长度（Max-Age）外过期。例如\n1  Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;   Cookie 的Secure和HttpOnly标记 安全的Cookie需要经过HTTPS协议通过加密的方式发送到服务器。即使是安全的也不应该将敏感信息存储在cookie中，因为他们本质上是不安全的，并且此标记不能提供真正的保护。\nHttpOnly的作用  会话Cookie中缺少HttpOnly属性会导致攻击者可以通过程序（JS脚本、Applet等）获取用户的Cookie信息，造成用户Cookie信息泄露，增加攻击者的跨站脚本攻击威胁。 HttpOnly是微软对Cookie做的扩展，该值指定Cookie是否可通过客户端脚本访问。 如果在Cookie中没有设置HttpOnly属性为True，可能导致Cookie被窃取。窃取的Cookie可以包含标识站点用户的敏感信息，如ASP.NET会话ID或Forms身份验证票证，攻击者可以重播窃取的Cookie，以便伪装成用户获取敏感信息，进行跨站脚本攻击等。  6.Cookie的作用域 Domain和Path标识定义了Cookie的作用域：即Cookie应该发给哪些URL。\nDomain标识制定了哪些主机可以接受Cookie。如果不指定，默认为当前主机(不包含子域名)。如果指定了Domain，则一般包含子域名。\n例如，如果设置Domain=mozilla.org，则Cookie也包含在子域名中（如developer.mozilla.org）。\n例如，设置Path=/docs,则以下地址会匹配\n  /docs\n  /docs/Web\n  /docs/Web/HTTP\n  /docs....\n  ","title":"Cookie和Session"},{"link":"https://blog.dpf114.top/posts/jwt%E5%92%8Csession-cookies%E4%B8%B4%E6%97%B6cookies/","text":"JSON Web Token简称JWT，它和Session Cookies(临时Cookies)都可以为网站提供用户的身份认证，但是它们不是一回事。\n下对对JWT和Session进行相关探究。\n1.JWT和Session Cookies的相同之处 在探究JWT和Session Cookies之前，有必要先去理解它们的相同之处。\n它们既可以对用户身份进行验证(登录验证，页面跳转验证\u0026hellip;)。\n如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为HTTP是一个无状态协议。这也就意味着当你访问某个网页，然后点击同一站点上的另一个页面是，服务器额内存中将不会记住你之前的操作。\nJWT和Session Cookies就是用来处理在不同页面之间切换，保存用户登录信息的机制。\n也就是说，这两种技术都是用来保存你的登录状态，能够让你在浏览任意受密码保护的网站。通过每次新的请求时对用户数据进行身份验证来解决此问题。\n所以JWT和Session Cookies的相同之处是：它们能够支持你在发送不同请求之间，记录并验证你的登录状态的一种机制。\n2.什么是Session Cookies Session Cookies 也称为会话 Cookies,在Session Cookies中，用户的登录装填会保存在服务器的内存中。当用户登录时，Session就被服务端安全的创建。\n在每次请求时，服务器就会从会话Cookie中读取SessionId，如果服务端的数据读取的SessionId相同，那么服务器就会发送响应数据给浏览器，允许用户登录。\n3.什么是JSON Web Token Json Web Token的简称就是JWT，通常可以称为JSON令牌,它是RFC7519中定义的用于安全的将信息作为JSON对象 进行传输的一种形式。JWT中存储的信息是经过数字签名的，因此可以被信任和理解。可以利用HMAC\n算法或使用RSA/ESDSA的公用/专用秘钥对JWT进行签名。\nJWT作用主要有以下两点\n 认证（Authorization）：这是使用JWT最常见的一种情况，一旦用户登录，后面每个请求都会包含JWT，从而允许用户访问该令牌锁允许的路由、服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小。 信息交换（Infomation Exchange）：JWT是能够安全传输信息的一种方式。通过使用公钥/私钥对JWT进行签名认证。此外，由于签名使用head和playload计算的，因此你还可以验证内容是否篡改。  4.JWT的格式 JWT由三部分组成（Header、Payload、Signature），每个部分用.分割，一个简单的组成如下图：\n下面分别对各个部分进行探究。\nHeader Header 是JWT的标头，它通常由两部分组成：令牌的类型（即JWT）和前面算法，例如HMAC SH256或RSA。\n例如\n1 2 3  { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; }   指定类型和签名算法后，JSON被Base64url编码形成JWT的第一部分。\nPayload JWT的第二部分是载荷Payoad，Payload中包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明：registered、public和private声明。\n  registered声明：包含一组建议使用的预定义声明，主要包括\n   ISS 签发人     Iss(issuer) 签发人   exp(expiration time) 过期时间   sub(subject) 主题   aud(audience) 受众   nbf(Not Before) 生效时间   iat(Issued At) 签发时间   jti(JWT ID) 编号      public 声明：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。\n  private 声明：自定义声明，旨在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。\n  例如\n1 2 3 4 5  { \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;admin\u0026#34;: true }   然后Payload JSON块会被Base64Url编码形成JWT第二部分。\nSignature JWT的第三部分是一个签证(签名)信息，这个签证信息由三部分组成。\n header playload secret  比如我们需要用 HMAC SHA256算法进行签名\n1 2 3 4  HMACSHA256( base64UrlEncode(header) + \u0026#34;.\u0026#34; + base64UrlEncode(payload), secret)   签名用于验证消息在此过程中有没有修改，并且对于使用私钥进行签名的令牌，它还可以验证JWT的发送者的真实身份。\n拼凑在一起 现在我们把上面的由三个点分隔的Base64-URL字符串部分组成在一起，这个字符串可以在HTML和HTTP环境中轻松传递这些字符串。\n下面是一个完整的JWT示例\n1  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gR G9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ   ![image-20200822151559588](/Users/dpf/Library/Application Support/typora-user-images/image-20200822151559588.png)\n5.JWT和Session Cookies的不同 JWT和Session Cookies都提供安全的用户身份验证，但是它们有以下几点不同\n密码签名 JWT具有加密签名，而Session Cookies没有。\nJSON是无状态的 JWT是无状态的因为声明被存储在客户端，而不是服务器中。\n身份验证可以在本地进行，而不是请求必须通过服务器数据或类似位置中进行。这就意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据进行通信，也无需在此过程中消耗大量资源。\n可扩展性 Session Cookies是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。由于JWT是无状态的，在许多情况下，它们可以节省服务器资源。因此JWT要比Session Cookies具有更强的可扩展性。\nJWT支持跨域认证 Session Cookies只能在单个节点域或者子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。如果你希望自己的网站和其他站点建立安全连接时，这是一个问题。\n使用JWT可以解决这个问题，使用JWT能够通过多个节点进行用户认证，也就是我们常说的跨域认证\n6.JWT和Session Cookies的选型 我们上面探讨了和Cookies的不同点，相信你会对选型有些了解，大致来说对于只需要登录用户并访问储存站点数据库中的一些信息的中小型网站来说，Session Cookies就可以满足。\n如果你有企业站点，应用程序附近的站点，并且需要处理大量的请求，尤其是第三方或很多第三方，则JWT更适合。\n","title":"jwt和Session cookies（临时cookies）"},{"link":"https://blog.dpf114.top/posts/https/","text":"1.HTTPS为什么会出现 一个新技术的出现必定是为了解决某种问题的。什么问题呢？一个简答的回答就是HTTP的安全性问题。由于HTTP采用明文传输，①在传输过程中任何人都有可能从中捕获、修改或者伪造请求发送，；②HTTP传输过程中不会验证通信双方的身份，HTTP信息交换双方可能会遭到伪装；③HTTP传输过程中，接收双方不会验证报文的完整性\n2.什么是HTTPS 回顾之前HTTP的定义：HTTP是一种超文本传输协议􏹒􏴛􏰙􏲺􏲻􏳅􏳆(Hypertext Transfer Protocol)，\n它是一个计算机实际里专门在两点时间传输文字、图片、音频、视频等超文本数据的约定和规范。\nHTTPS的全称Hypertext Transfer Protocol Secure,它用来在计算机网络上的两个端系统之间进行安全的交换信息，它相当于在HTTP的基础上加了一个Secure。HTTPS定义：HTTPS是在一个计算机世界里专门在两点之间安全的传输文字、图片、音频、视频等超文本数据的约定和规范。HTTPS是HTTP协议的一种扩展，它本身并不保证传输的安全性，那么谁来保证安全性呢？在HTTPS中，使用传输安全性(TLS)或安全套接字层(SSL)对通信协议进行加密，也就是HTTP+SSL(TLS) = HTPPS。\n3.HTTPS 做了什么？ HTTPS协议提供了是三个关键性指标\n 加密(Encryption)：HTTPS通过对数据加密来使其免受窃听者对数据的监听。 数据一致性(Data integrity)：数据在传输过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端。 身份认证(Authentication)：指确认对方的真实身份，它可以防止中间人攻击并建立用户信任。  怎么知道网站用HTTPS还是HTTP呢？看下图可以很容易知道。\n除了协议名称和默认端口外(HTTP默认80，HTTPS默认443)，HTTPS协议在语法、语义和HTTP一样，HTTP有的，HTTPS也照单全收。那么，HTTPS如何做到HTTP不能做到的安全性呢？关键在于这个S也就是SSL/TLS。\n4.什么是SSL/TLS 4.1 认识SSL/TLS TLS(Transport Layer Security) 􏰄 是SSL(Secure Socket Layer)的后续版本，它们用于在互联网两台计算机之间身份认证和加密的一种协议。\n 注意：在互联网中，很多名称都可以进行互换\n 我们都知道一些在线业务（比如在线支付）最重要的一个步骤是创建一个值得信赖的交易环境，能够让客户安心的进行交易，SSL/TLS就保证了这一点，SSL/TLS通过将称为X.509证书的数字文档将网站和公司的实体信息绑定到加密秘钥来进行工作。每一个秘钥对（key pairs）都有一个私有秘钥（private key）和公有秘钥（public key）私有秘钥是独有的，一般位于服务器上，用于解密由公共秘钥加密过的信息；公有秘钥是公有的，与服务器进行交互的是每个人都可以持有的公有秘钥，用公钥加密过的信息只能由私有秘钥来解密。\n 什么是 X.509：X.509 是公开密钥证书的标准格式，这个文档将加密密钥与（个人或组织）进行安全的关联。\nX.509 主要应用如下\n SSL/TLS 和 HTTPS 用于经过身份验证和加密的 Web 浏览 通过 S/MIME 协议签名和加密的电子邮件 代码签名：它指的是使用数字证书对软件应用程序进行签名以安全分发和安装的过程。  ![image-20200818144100127](/Users/dpf/Library/Application Support/typora-user-images/image-20200818144100127.png)\n通过使用由知名公共证书颁发机构（例如SSL.com）颁发的证书对软件进行数字签名，开发人员可以向最终用户保证他们希望安装的软件是由已知且受信任的开发人员发布；并且签名后未被篡改或损害。\n 还可用于文档签名  还可用于客户端认证   政府签发的电子身份证（详见 https://www.ssl.com/article/pki-and-digital-certificates-for-government/）   4.2 HTTPS的内核是HTTP HTTPS并不是一项新的应用层协议，只是HTTP通信接口和部分SSL和TLS替代而已。通常情况下，HTTP会直接和TCP进行通信。在使用SSL的HTTPS后，则会演变为和SSL进行通信，然后再由SSL和TCP进行通信。也就是说，HTTPS就是身披了一层SSL的HTTP。\nSSL 是一个独立的协议，不只有 HTTP 可以使用，其他应用层协议也可以使用，比如 SMTP(电子邮件协议)、Telnet(远程登录协议) 等都可以使用。\n5.探究HTTPS HTTPS非常强，它强在哪里呢？就是它的安全性（加密协议），所以这里探究的就是它的加密协议SSL/TLS。\nSSL即安全套接字层，它在OSI七层网络模型中处于第五次，SSL在1999年被**IETF（互联网工程组）**更名TLS，即传输安全层，知道现在，TLS一共出现过三个版本，1.1、1.2和1.3，目前最广泛使用的是1.2，接下来的探究都是基于TLS 1.2的版本上的。\nTLS用于两个同心应用程序之间提供保密性和数据完整性。TLS由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个自协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术（如果你觉得一项技术很简单，那你只是没有学到位，任何技术都是有美感的，牛逼的人只是欣赏，并不是贬低）。\n说了这么多，我们还没有看到TLS的命名规范，下面举一个TLS的例子来看一下TLS的结构（可以参考 https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml）\n1  ECDHE-ECDSA-AES256-GCM-SHA384   这是啥意思呢？是不是看起来有点懵，但其实是有套路的，因为TLS的密码套件比较规范，基本格式是：秘钥交换算法-签名算法-对称加密算法-摘要算法组成的一个密码串，有时候还有分组模式，我们来看一下上面字符串意思：使用 ECDHE 进行密钥交换，使用 ECDSA 进行签名和认证，然后使用 AES 作为对称加密算法，密钥的长度是 256 位，使用 GCM 作为分组模式，最后使用 SHA384 作为摘要算法。\nTLS在根本上使用对称加密和非对称加密两种形式。\n5.1 对称加密 在了解对称加密之前，我们先来了解一下密码学的东西，在密码学中，有几个概念：明文、密文、加密、解密。\n 明文(Plaintext)，一般认为明文是有意义的字符或者比特集，或者是通过某种公开编码就能获得的消息。明文通常用 m 或 p 表示 密文(Ciphertext)，对明文进行某种加密后就变成了密文 加密(Encrypt)，把原始的信息（明文）转换为密文的信息变换过程 解密(Decrypt)，把已经加密的信息恢复成明文的过程。  对称加密(Symmetrical Encryption)顾名思义就是指加密和解密时使用的密钥都是同样的密钥。只要保证了密钥的安全性，那么整个通信过程也就是具有了机密性。\nTLS 里面有比较多的加密算法可供使用，比如 DES、3DES、AES、ChaCha20、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。目前最常用的是 AES-128, AES-192、AES-256 和 ChaCha20。\nDES 的全称是 Data Encryption Standard(数据加密标准) ，它是用于数字数据加密的对称密钥算法。尽管其 56 位的短密钥长度使它对于现代应用程序来说太不安全了，但它在加密技术的发展中具有很大的影响力。\n3DES 是从原始数据加密标准（DES）衍生过来的加密算法，它在 90 年代后变得很重要，但是后面由于更加高级的算法出现，3DES 变得不再重要。\nAES-128, AES-192 和 AES-256 都是属于 AES ，AES 的全称是Advanced Encryption Standard(高级加密标准)，它是 DES 算法的替代者，安全强度很高，性能也很好，是应用最广泛的对称加密算法。\nChaCha20 是 Google 设计的另一种加密算法，密钥长度固定为 256 位，纯软件运行性能要超过 AES，曾经在移动客户端上比较流行，但 ARMv8 之后也加入了 AES 硬件优化，所以现在不再具有明显的优势，但仍然算得上是一个不错算法。\n加密分组 对称加密算法还有一个分组模式 的概念，对于 GCM 分组模式，只有和 AES，CAMELLIA 和 ARIA 搭配使用，而 AES 显然是最受欢迎和部署最广泛的选择，它可以让算法用固定长度的密钥加密任意长度的明文。\n最早有 ECB、CBC、CFB、OFB 等几种分组模式，但都陆续被发现有安全漏洞，所以现在基本都不怎么用了。最新的分组模式被称为 AEAD（Authenticated Encryption with Associated Data），在加密的同时增加了认证的功能，常用的是 GCM、CCM 和 Poly1305。\n\r对于对称加密看起来似乎很牛逼，但是它也有缺点（安全问题）。从上面我们都知道，对称加密 加密和解密是同一秘钥，加密方对原始数据进行加密后，然后再把秘钥传给解密方才能进行解密，这回造成什么问题呢？这就好比《小兵张嘎》去送信（信已经被加密过），但是嘎子还拿着解密的密码，那嘎子要是在途中被鬼子发现了，那这信可就是被完全的暴露了。所以，对称加密存在风险。\n5.2 非对称加密 非对称加密(Asymmetrical Encryption) 也被称为公钥加密，相对于对称加密来说，非对称加密是一种新的改良加密方式。密钥通过网络传输交换，它能够确保及时密钥被拦截，也不会暴露数据信息。非对称加密中有两个密钥，一个是公钥，一个是私钥，公钥进行加密，私钥进行解密。公开密钥可供任何人使用，私钥只有你自己能够知道。\n使用公钥加密的文本只能使用私钥解密，同时，使用私钥加密的文本也可以使用公钥解密。公钥不需要具有安全性，因为公钥需要在网络间进行传输，非对称加密可以解决密钥交换的问题。网站保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。\n非对称加密算法的设计要比对称算法难得多（我们不会探讨具体的加密方式），常见的比如 DH、DSA、RSA、ECC 等。\n其中 RSA 加密算法是最重要的、最出名的一个了。例如 DHE_RSA_CAMELLIA128_GCM_SHA256。它的安全性基于 整数分解，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。\nTLS 是使用对称加密和非对称加密 的混合加密方式来实现机密性。\n5.3 混合加密 RSA 的运算速度非常慢，而 AES 的加密速度比较快，而 TLS 正是使用了这种混合加密方式。在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE ，首先解决密钥交换的问题。然后用随机数产生对称算法使用的会话密钥（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。\n现在我们使用混合加密的方式实现了机密性，是不是就能够安全的传输数据了呢？还不够，在机密性的基础上还要加上完整性、身份认证的特性，才能实现真正的安全。而实现完整性的主要手段是 摘要算法(Digest Algorithm)\n5.4 摘要算法 如何实现完整性呢？在 TLS 中，实现完整性的手段主要是 摘要算法(Digest Algorithm)。摘要算法你不清楚的话，MD5 你应该清楚，MD5 的全称是 Message Digest Algorithm 5，它是属于密码哈希算法(cryptographic hash algorithm)的一种，MD5 可用于从任意长度的字符串创建 128 位字符串值。尽管 MD5 存在不安全因素，但是仍然沿用至今。MD5 最常用于验证文件的完整性。但是，它还用于其他安全协议和应用程序中，例如 SSH、SSL 和 IPSec。一些应用程序通过向明文加盐值或多次应用哈希函数来增强 MD5 算法。\n 什么是加盐？在密码学中，盐就是一项随机数据，用作哈希数据，密码或密码的单向函数的附加输入。盐用于保护存储中的密码。例如\n􏱙􏱚􏰄􏳇􏼯􏵡􏱡􏳈􏲈􏱕􏱣􏰖 􏼯 􏲜􏰄􏰫􏺮􏶆􏴉􏲢􏴞􏰖􏰣􏰢􏺝􏹮􏲢􏴞􏰖􏳈􏲈􏱮􏳈􏲈􏰡 􏴕􏶗 􏼩􏲢􏰡􏼄 􏳇􏲻􏷴􏰍􏼯􏰣􏰲􏳗􏳘􏳍􏳎􏱣􏰡􏳈􏲈􏰍􏴑􏱩\n什么是单向？就是在说这种算法没有密钥可以进行解密，只能进行单向加密，加密后的数据无法解密，不能逆推出原文。\n 我们再回到摘要算法的讨论上来，其实你可以把摘要算法理解成一种特殊的压缩算法，它能够把任意长度的数据压缩成一种固定长度的字符串，这就好像是给数据加了一把锁。\n除了常用的 MD5 是加密算法外，SHA-1(Secure Hash Algorithm 1) 也是一种常用的加密算法，不过 SHA-1 也是不安全的加密算法，在 TLS 里面被禁止使用。目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。\nSHA-2 的全称是Secure Hash Algorithm 2 ，它在 2001 年被推出，它在 SHA-1 的基础上做了重大的修改，SHA-2 系列包含六个哈希函数，其摘要（哈希值）分别为 224、256、384 或 512 位：SHA-224, SHA-256, SHA-384, SHA-512。分别能够生成 28 字节、32 字节、48 字节、64 字节的摘要。\n有了 SHA-2 的保护，就能够实现数据的完整性，哪怕你在文件中改变一个标点符号，增加一个空格，生成的文件摘要也会完全不同，不过 SHA-2 是基于明文的加密方式，还是不够安全，那应该用什么呢？\n安全性更高的加密方式是使用 HMAC，在理解什么是 HMAC 前，你需要先知道一下什么是 MAC。\nMAC 的全称是message authentication code，它通过 MAC 算法从消息和密钥生成，MAC 值允许验证者（也拥有秘密密钥）检测到消息内容的任何更改，从而保护了消息的数据完整性。\nHMAC 是 MAC 更进一步的拓展，它是使用 MAC 值 + Hash 值的组合方式，HMAC 的计算中可以使用任何加密哈希函数，例如 SHA-256 等。\n现在我们又解决了完整性的问题，那么就只剩下一个问题了，那就是认证，认证怎么做的呢？我们在向服务器发送数据的过程中，黑客（攻击者）有可能伪装成任何一方来窃取信息。它可以伪装成你，来向服务器发送信息，也可以伪装称为服务器，接受你发送的信息。那么怎么解决这个问题呢？\n5.5 认证 如何确定你自己的唯一性呢？我们在上面的叙述过程中出现过公钥加密，私钥解密的这个概念。提到的私钥只有你一个人所有，能够辨别唯一性，所以我们可以把顺序调换一下，变成私钥加密，公钥解密。使用私钥再加上摘要算法，就能够实现数字签名，从而实现认证。\n到现在，综合使用对称加密、非对称加密和摘要算法，我们已经实现了加密、数据认证、认证，那么是不是就安全了呢？非也，这里还存在一个数字签名的认证问题。因为私钥是是自己的，公钥是谁都可以发布，所以必须发布经过认证的公钥，才能解决公钥的信任问题。\n所以引入了 CA，CA 的全称是 Certificate Authority，证书认证机构，你必须让 CA 颁布具有认证过的公钥，才能解决公钥的信任问题。\n全世界具有认证的 CA 就几家，分别颁布了 DV、OV、EV 三种，区别在于可信程度。DV 是最低的，只是域名级别的可信，EV 是最高的，经过了法律和审计的严格核查，可以证明网站拥有者的身份（在浏览器地址栏会显示出公司的名字，例如 Apple、GitHub 的网站）。不同的信任等级的机构一起形成了层级关系。\n通常情况下，数字证书的申请人将生成由私钥和公钥以及证书签名请求（CSR）组成的密钥对。CSR是一个编码的文本文件，其中包含公钥和其他将包含在证书中的信息（例如域名，组织，电子邮件地址等）。密钥对和 CSR生成通常在将要安装证书的服务器上完成，并且 CSR 中包含的信息类型取决于证书的验证级别。与公钥不同，申请人的私钥是安全的，永远不要向 CA（或其他任何人）展示。\n生成 CSR 后，申请人将其发送给 CA，CA 会验证其包含的信息是否正确，如果正确，则使用颁发的私钥对证书进行数字签名，然后将其发送给申请人。\n","title":"HTTPS"},{"link":"https://blog.dpf114.top/posts/http%E4%BC%98%E7%BC%BA%E7%82%B9/","text":"1.HTTP的优点 简单灵活易扩展 HTTP最突出的优点是简单、灵活、易于扩展。\nHTTP协议比较简单，它的主要组成就是 header+body,头部信息也是简单的文本格式，而且HTTP的请求报文根据英文也能猜出个大概的意思，降低学习门槛。\n所以，在简单的基础上，HTTP协议又多了灵活和易扩展的优点。\nHTTP协议里的请求方法、URI、状态码、原因短语、头部字段等每一个核心组成要素都没有被限制死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由。\n应用广泛 因为过于简单，普及，因此应用很广泛。因为HTTP协议本身不属于一种语言，它并不限制某种语言或者操作系统，所以天然具有跨语言、跨平台的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有编程语言都有HTTP调用库和外围的开发测试工具。\n无状态 无状态既是有点又是缺点。优点是可以减轻服务器的负担，能够更多的cpu和内存用来对外提供服务。\n明文 明文传输其实也是既是优点也是缺点。明文的意思是协议里的报文(header部分)不使用二进制数据，而是用简单可阅读文本的形式。\n优点(相对于TCP、UDP二进制协议)就是抓包容易，方便开发人员开发调试。\n2.HTTP的缺点 无状态 无法做连续多个步骤的操作。例如：加入购物出，结算，支付。每次都需要验证身份信息，因为无状态所以无法连续。解决办法，就是cookie。\n明文 不安全，传输内容可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被改过。\n","title":"HTTP优缺点"},{"link":"https://blog.dpf114.top/posts/http%E8%AE%A4%E8%AF%81/","text":"HTTP提供了用于访问控制和身份认证的功能，下面对HTTP的权限和认证功能进行介绍。\n1.通用HTTP认证框架 RFC 7235 定义了 HTTP 身份认证框架，服务器可以根据其文档的定义来检查客户端请求。客户端也可以根据其文档定义来提供身份验证信息。\n请求/响应的工作流程如下：\n服务器以401(未授权) 的状态响应客户端告诉客户端服务器需要认证信息，客户端提供至少一个 www-Authenticate 的响应标头进行授权信息的认证。想要通过服务器进行身份认证的客户端可以在请求标头字段中添加认证标头进行身份认证，一般的认证过程如下\n首先客户端发起一个 HTTP 请求，不带有任何认证标头，服务器对此 HTTP 请求作出响应，发现此 HTTP 信息未带有认证凭据，服务器通过 www-Authenticate标头返回 401 告诉客户端此请求未通过认证。然后客户端进行用户认证，认证完毕后重新发起 HTTP 请求，这次 HTTP 请求带有用户认证凭据（注意，整个身份认证的过程必须通过 HTTPS 连接保证安全），到达服务器后服务器会检查认证信息，如果不符合服务器认证信息，会返回 403 Forbidden 表示用户认证失败，如果满足认证信息，则返回 200 OK。\n我们知道，客户端和服务器之间的 HTTP 连接可以被代理缓存重新发送，所以认证信息也适用于代理服务器。\n2.代理认证 由于资源认证和代理认证可以共存，因此需要不同的头和状态码，在代理的情况下，会返回状态码 407(需要代理认证)， Proxy-Authenticate 响应头包含至少一个适用于代理的情况，Proxy-Authorization请求头用于将证书提供给代理服务器。下面分别来认识一下这两个标头\n2.1 Proxy-Authenticate HTTP Proxy-Authenticate 响应标头定义了身份验证方法，应使用该身份验证方法来访问代理服务器后面的资源。它将请求认证到代理服务器，从而允许它进一步发送请求。例如\n1 2  Proxy-Authenticate: Basic Proxy-Authenticate: Basic realm=\u0026#34;Access to the internal site\u0026#34;   2.2 Proxy-Authorization 这个 HTTP 请求标头和上面的 Proxy-Authenticate 拼接很相似，但是概念不同，这个标头用于向代理服务器提供凭据，例如\n1  Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l   下面是代理服务器的请求/响应认证过程\n3. 禁止访问 如果代理服务器收到的有效凭据不足以获取对给定资源的访问权限，则服务器应使用403 Forbidden状态代码进行响应。与 401 Unauthorized 和 407 Proxy Authorization Required 不同，该用户无法进行身份验证。\nWWW-Authenticate 和 Proxy-Authenticate 头 WWW-Authenticate 和 Proxy-Authenticate 响应头定义了获得对资源访问权限的身份验证方法。他们需要指定使用哪种身份验证方案，以便希望授权的客户端知道如何提供凭据。它们的一般表示形式如下\n1 2  WWW-Authenticate: \u0026lt;type\u0026gt; realm=\u0026lt;realm\u0026gt; Proxy-Authenticate: \u0026lt;type\u0026gt; realm=\u0026lt;realm\u0026gt;   我想你从上面看到这里一定会好奇 \u0026lt;type\u0026gt; 和 realm是什么东西，现在就来解释下。\n \u0026lt;type\u0026gt; 是认证协议，Basic 是下面协议中最普遍使用的   RFC 7617 中定义了Basic HTT P身份验证方案，该方案将凭据作为用户ID /密码对传输，并使用 base64 进行编码。(感兴趣的同学可以看看 https://tools.ietf.org/html/r\u0026hellip;)\n 其他的认证协议主要有\n   认证协议 参考来源     Basic 查阅 RFC 7617，base64编码的凭据   Bearer 查阅 RFC 6750，承载令牌来访问受 OAuth 2.0保护的资源   Digest 查阅 RFC 7616，Firefox仅支持md5哈希，请参见错误bug 472823以获得SHA加密支持   HOBA 查阅 RFC 7486   Mutual 查阅 RFC 8120   AWS4-HMAC-SHA256 查阅 AWS docs     realm 用于描述保护区或指示保护范围，这可能是诸如 Access to the staging site(访问登陆站点) 或者类似的，这样用户就可以知道他们要访问哪个区域。  Authorization 和 Proxy-Authorization 标头 Authorization 和 Proxy-Authorization 请求标头包含用于通过代理服务器对用户代理进行身份验证的凭据。在此，再次需要类型，其后是凭据，取决于使用哪种身份验证方案，可以对凭据进行编码或加密。一般表示如下\n1 2  Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l   4.常用认证方式 在HTTP中，常用的认证方式有以下几种：\n Basic认证：访问API时，浏览器会自动弹出一个对话框去输入用户名/密码 Digest认证：摘要算法认证(MD5、SHA2\u0026hellip;) SSL Client 认证：HTTPS常用此认证 表单认证：最基本的认证方式  4.1 Basic 认证 ![image-20200819114649471](/Users/dpf/Library/Application Support/typora-user-images/image-20200819114649471.png)\n 当用户向一个需要BASIC认证的服务器发送请求时，服务器通过 www-Authenticate标头返回 401 告诉客户端请求此资源需要BASIC认证。 用户输入用户名/密码以Base64编码之后发送给服务器 服务器校验成功返回状态码200，失败返回401  BASIC认证虽然采用Base64编码方式，但这并不是加密处理，不需要任何附加信息即可解码。在HTTP等非加密线路上进行传输容易被人窃听，所以说BASIC认证存在安全性问题。除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。\n4.2 Digest 认证 Digest 即摘要算法(MD5，SHA1\u0026hellip;)，相对于基本认证，主要有如下改进：\n 密码不发送明文 可以有效防止恶意用户进行重放攻击 可以有选择的防止对报文内容的篡改  ![image-20200819120905609](/Users/dpf/Library/Application Support/typora-user-images/image-20200819120905609.png)\n 认证响应时①：\n首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。\n认证请求②：首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到 的响应中的字段。\n 看到上面出现了那么多之前没见过的参数，是不是有点慌（或是兴奋）？别着急，这里先给出一个概览：\n WWW-Authentication：用来定义使用何种方式（Basic、Digest、Bearer等）去进行认证以获取受保护的资源 realm：表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码 qop：保护质量，包含auth（默认的）和auth-int（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值 nonce：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击 nc：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求 cnonce：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护 response：这是由用户代理软件计算出的一个字符串，以证明用户知道口令（密码加密后的字符串） Authorization-Info：用于返回一些与授权会话相关的附加信息 rspauth：响应摘要，用于客户端对服务端进行认证 stale：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定stale=true，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了  DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的 客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护 机制，但并不存在防止用户伪装的保护机制。\n4.3 SSL Client 认证 SSL认证安全级别较高，但需要承担证书费用。SSL认证过程中涉及到一些重要的概念，数字证书机构的公钥、证书的私钥和公钥、非对称算法（配合证书的私钥和公钥使用）、对称密钥、对称算法（配合对称密钥使用）。\n大致的认证步骤如下： 第一步：客户端请求服务资源，服务器要求客户端出示数字证书。 第二步：客户端发送数字证书 第三步：服务器通过数字证书机构的公钥验证数字证书的合法性，验证通过后取出证书的公钥。 第四步：服务端随机生成一个随机数即为对称密钥，并使用非对称算法和证书公钥加密。这个加密后的字符串，只有发送的客户端能解。 第五步：客服端使用非对称解密算法和证书私钥获取服务端发送的对称密钥。后续客户端和服务端的请求直接基于对称算法和对称密钥。由于只有客户端和服务端有对称密钥，所以后续发送的请求较安全。\nSSL可以防泄漏、假冒、重放，所以在Web系统中得到了广泛的应用。\nSSL客户端认证在实际中用得不多，因为一来需要在客户端中安装证书（升级麻烦）、二来需要承担证书费用。\n4.4 表单认证 基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务 器上的 Web 应用程序发送登录信息(Credential)，按登录信息的验 证结果认证。多数情况下，输入已事先登录的用户 ID(通常是任意字符串或邮件地址)和密码等登录信息后，发送给 Web 应用程序，基于认证结果 来决定认证是否成功。\n","title":"HTTP认证"},{"link":"https://blog.dpf114.top/posts/http%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/","text":"1.什么是跨域请求CROS CROS 的全称是 Cross-Origin Resource Sharing(CROS)，中文译为 跨域资源共享，它是一种机制，它使用附加的HTTP标头来告诉浏览器以使Web应用程序在一个来源运行，并从另一个来源访问选定的资源。Web应用程序请求其来源（域Origin）不同的资源时，将执行跨域HTTP请求。所以说你要判断一个请求是否需要跨域，你只要判断其是否具有相同的域。\n2. Origin Web 概念中域(Origin) 的内容由scheme(protocol) - 协议，host(domain) - 主机和用于访问它的 URL port - 端口定义。仅仅当 scheme 、host、port 都匹配时，两个对象才有相同的来源。这种协议相同，域名相同，端口相同的安全策略也被称为 同源策略（Same Origin Policy)。某些操作仅限于具有相同来源的内容，可以使用 CORS 取消此限制。\n 下面是跨域问题的例子，看看你是否清楚什么是跨域了  1 2  (1) http://example.com/app1/index.html (2) http://example.com/app2/index.html   上面这两个 URL 是否具有跨域问题呢？\n上面两个 URL 是不具有跨域问题的，因为这两个 URL 具有相同的协议(scheme)和主机(host)\n 那么下面这两个是否具有跨域问题呢？  1 2  http://Example.com:80 http://example.com   这两个 URL 也不具有跨域问题，为什么不具有，端口不一样啊。其实它们两个端口是一样的。\n或许你会认为这两个 URL 是不一样的，放心，关于一样不一样的论据我给你抛出来了\n 协议和域名部分是不区分大小写的，但是路径部分则根据服务器平台而定。Windows 和 Mac OS X 系统是不区分大小写的，而采用UNIX和Linux系的服务器系统是区分大小写的，\n 也就是说上面的 Example.com 和 example.com 其实是一个网址，并且由于两个地址具有相同的 scheme 和 host ，默认情况下服务器通过端口80传递 HTTP 内容，所以上面这两个地址也是相同的。\n 下面这两个 URL 地址是否具有跨域问题？  1 2  http://example.com/app1 https://example.com/app2   这两个 URL 的 scheme 不同，所以这两个 URL 具有跨域问题\n 再看下面这三个 URL 是否具有跨域问题  1 2 3  http://example.com http://www.example.com http://myapp.example.com   这三个 URL 也是具有跨域问题的，因为它们隶属于不通服务器的主机 host。\n 下面这两个 URL 是否具有跨域问题  1 2  http://example.com http://example.com:8080   这两个 URL 也是具有跨域问题，因为这两个 URL 的默认端口不一样。\n3.同源策略 处于安全的因素，浏览器限制了从脚本发起跨域的 HTTP 请求。 XMLHttpRequest 和其他 Fetch 接口 会遵循 同源策略(same-origin policy)。也就是说使用这些 API 的应用程序想要请求相同的资源，那么他们应该具有相同的来源，除非来自其他来源的响应包括正确的 CORS 标头也可以。\n同源策略是一种很重要的安全策略，它限制了从一个来源加载的文档或脚本如何与另一个来源的资源进行交互。 它有助于隔离潜在的恶意文档，减少可能的攻击媒介。\n我们上面提到，如果两个 URL 具有相同的协议、主机和端口号（如果指定）的话，那么两个 URL 具有相同的来源。下面有一些实例，你判断一下是不是具有相同的来源\n目标来源 http://store.company.com/dir/page.html\n   URL Outcome Reason     http://store.company.com/dir2\u0026hellip; 相同来源 只有path不同   http://store.company.com/dir/\u0026hellip; 相同来源 只有path不同   https://store.company.com/pag\u0026hellip; 不同来源 协议不通   http://store.company.com:81/dir/page.html 不同来源 默认端口不同   http://news.company.com/dir/p\u0026hellip; 不同来源 主机不同    现在我带你认识了两遍不同的源，现在你应该知道如何区分两个 URL 是否属于同一来源了吧！\n好，你现在知道了什么是跨域问题，现在我要问你，哪些请求会产生跨域请求呢？这是我们下面要讨论的问题\n4.哪些请求使用CORS？  调用 XMLHttpRequest  XMLHttpRequest 是什么？（我是后端程序员，前端不太懂，简单解释下，如果解释的不好，还请前端大佬们不要胖揍我）\n所有的现代浏览器都有一个内置的 XMLHttpReqeust 对象，这个对象可以用于从服务器请求数据。\nXMLHttpReqeust 对于开发人员来说很重要，XMLHttpReqeust 对象可以用来做下面这些事情\n 更新网页无需重新刷新页面 页面加载后从服务器请求数据 页面加载后从服务端获取数据 在后台将数据发送到服务器  使用 XMLHttpRequest(XHR) 对象与服务器进行交互，你可以从 URL 检索数据从而不必刷新整个页面，这使网页可以更新页面的一部分，而不会中断用户的操作。XMLHttpRequest 在 AJAX 异步编程中使用很广泛。\n Fetch api。  Fetch 提供了请求和响应对象（以及其他网络请求）的通用定义。它还提供了相关概念的定义，例如 CORS 和 HTTP Origin 头语义，并在其他地方取代了它们各自的定义。\n Web 字体（用于 CSS 中@ font-face中的跨域字体使用），以便服务器可以部署 TrueType 字体，这些字体只能由允许跨站点加载和使用的网站使用。 WebGL 纹理 使用 drawImage() 绘制到画布上的图像/视频帧 图片的 CSS 形状  5.跨域功能概述 跨域资源共享标准通过添加新的 HTTP 标头来工作，这些标头允许服务器描述允许哪些来源从 Web 浏览器读取信息。另外，对于可能导致服务器数据产生副作用的 HTTP 请求方法（尤其是 GET 或者具有某些 MIME 类型 POST 方法以外 HTTP 方法），该规范要求浏览器预检请求，使用 HTTP OPTIONS 请求方法从服务器请求受支持的方法，然后在服务器批准后发送实际请求。服务器还可以通知客户端是否应与请求一起发送凭据（例如 Cookies 和 HTTP 身份验证）。\n CORS故障会导致错误，但是出于安全原因，JavaScript尚无法提供有关错误的详细信息。所有代码都知道发生了错误。确定具体出问题的唯一方法是查看浏览器的控制台以获取详细信息。\n 6.访问控制方案 下面跟大家探讨三种方案，这些方案演示了跨域资源共享的工作方式。所有这些示例都使用XMLHttpRequest，可以在任何支持的浏览器中进行跨站点请求。\n6.1 简单请求 有些请求不会触发CORS预检（第二种方案）,“简单请求”是满足以下所有条件的请求：\n 允许方法：GET、HEAD、POST 除了由用户代理自动设置的标头（例如 Connection、User-Agent 或者在 Fetch 规范中定义为禁止标头名称的其他标头）外，唯一允许手动设置的标头是那些 Fetch 规范将其定义为 CORS安全列出的请求标头 ，它们是：  Accept Accept-Language Content-Language Content-Type（下面会介绍） DPR Downlink Save-Data Viewport-Width Width   Content-Type 标头的唯一允许的值是  application/x-www-form-urlencoded multipart/form-data text/plain   没有在请求中使用的任何 XMLHttpRequestUpload 对象上注册事件侦听器；这些可以使用XMLHttpRequest.upload 属性进行访问。 请求中未使用 ReadableStream对象。  例如，假定 web 内容 https://foo.example 想要获取 https://bar.other 域的资源，那么 JavaScript 中的代码可能会像下面这样写\n1 2 3 4 5 6  const xhr = new XMLHttpRequest(); const url = \u0026#39;https://bar.other/resources/public-data/\u0026#39;; xhr.open(\u0026#39;GET\u0026#39;, url); xhr.onreadystatechange = someHandler; xhr.send();   这使用 CORS 标头来处理特权，从而在客户端和服务器之间执行某种转换。\n让我们来看看这种情况下浏览器将发送到服务器的内容，并让我们看看服务器如何响应：\n1 2 3 4 5 6 7 8  GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: https://foo.example   注意请求的标头 Origin ，它表明调用来自于 https://foo.example。让我们看看服务器是如何响应的\n1 2 3 4 5 6 7 8 9 10  HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml […XML Data…]   服务端发送 Access-Control-Allow-Origin 作为响应。使用 Origin 标头和 Access-Control-Allow-Origin 展示了最简单的访问控制协议。在这个事例中，服务端使用 Access-Control-Allow-Origin 作为响应，也就说明该资源可以被任何域访问。\n如果位于https://bar.other的资源所有者希望将对资源的访问限制为仅来自https://foo.example的请求，他们应该发送如下响应\n1  Access-Control-Allow-Origin: https://foo.example   现在除了 https://foo.example 之外的任何域都无法以跨域方式访问到 https://bar.other 的资源。\n6.2 预检请求 和上面探讨的简单请求不同，预检请求首先通过 OPTIONS 方法向另一个域上的资源发送 HTTP 请求，用来确定实际请求是否可以安全的发送（是否能够接收对应URL，接收的请求方法有哪些，请求头\u0026hellip;）。跨站点这样被预检，因为它们可能会影响用户数据。\n下面是一个预检事例\n1 2 3 4 5 6  const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;POST\u0026#39;, \u0026#39;https://bar.other/resources/post-here/\u0026#39;); xhr.setRequestHeader(\u0026#39;X-PINGOTHER\u0026#39;, \u0026#39;pingpong\u0026#39;); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/xml\u0026#39;); xhr.onreadystatechange = handler; xhr.send(\u0026#39;\u0026lt;person\u0026gt;\u0026lt;name\u0026gt;Arun\u0026lt;/name\u0026gt;\u0026lt;/person\u0026gt;\u0026#39;);   上面的事例创建了一个 XML 请求体用来和 POST 请求一起发送。此外，设置了非标准请求头 X-PINGOTHER ，这个标头不是 HTTP/1.1 的一部分，但通常对 Web 程序很有用。由于请求的 Content-Type 使用 application/xml，并且设置了自定义标头，因此该请求被预检。如下图所示\n下面我们来看一下完整的客户端/服务器交互，首先是预检请求/响应\n1 2 3 4 5 6 7 8 9 10  OPTIONS /doc HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type   1 2 3 4 5 6 7 8 9 10  HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive   上面的1 -11 行代表预检请求，预检请求使用 OPYIIONS 方法，浏览器根据上面的 JavaScript 代码段所使用的请求参数确定是否需要发送此请求，以便服务器可以响应是否可以使用实际请求参数发送请求。OPTIONS 是一种 HTTP / 1.1方法，用于确定来自服务器的更多信息，并且是一种安全的方法，这意味着它不能用于更改资源。请注意，与 OPTIONS 请求一起，还发送了另外两个请求标头如下：\n1 2  Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type   Access-Control-Request-Method 标头作为预检请求的一部分通知服务器，当发送实际请求时，将使用POST 请求方法发送该请求。\nAccess-Control-Request-Headers 标头通知服务器，当发送请求时，它将与X-PINGOTHER 和 Content-Type 自定义标头一起发送。服务器可以确定这种情况下是否接受请求。\n下面的 1 - 10行是服务器发回的响应，表示POST 请求和 X-PINGOTHER 是可以接受的，我们着重看一下下面这几行\n1 2 3 4  Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400   服务器完成响应表明源 http://foo.example 是可以接受的 URL，能够允许 POST、GET、OPTIONS 进行请求，允许自定义标头 X-PINGOTHER, Content-Type。最后，Access-Control-Max-Age 以秒为单位给出一个值，这个值表示对预检请求的响应可以缓存多长时间，在此期间内无需发送其他预检请求。在这种情况下，86400秒是24小时。请注意，每个浏览器都有一个最大内部值，当Access-Control-Max-Age较大时，该内部值优先。\n完成预检请求后，将发送实际请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  POST /doc HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive X-PINGOTHER: pingpong Content-Type: text/xml; charset=UTF-8 Referer: https://foo.example/examples/preflightInvocation.html Content-Length: 55 Origin: https://foo.example Pragma: no-cache Cache-Control: no-cache \u0026lt;person\u0026gt;\u0026lt;name\u0026gt;Arun\u0026lt;/name\u0026gt;\u0026lt;/person\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:40 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 235 Keep-Alive: timeout=2, max=99 Connection: Keep-Alive Content-Type: text/plain [Some XML payload]   6.3 带凭证的请求 XMLHttpRequest 或 Fetch 和 CORS 最有趣的功能就是能够发出知道 HTTP Cookie 和 HTTP 身份验证的 凭证 请求。默认情况下，在跨站点 XMLHttpRequest 或 Fetch 调用中，浏览器将不发送凭据。调用 XMLHttpRequest对象或 Request 构造函数时必须设置一个特定的标志。\n在下面这个例子中，最初从 http://foo.example 加载的内容对设置了 Cookies 的 http://bar.other 上的资源进行了简单的 GET 请求， foo.example 上可能的代码如下\n1 2 3 4 5 6 7 8 9 10 11  const invocation = new XMLHttpRequest(); const url = \u0026#39;http://bar.other/resources/credentialed-content/\u0026#39;; function callOtherDomain() { if (invocation) { invocation.open(\u0026#39;GET\u0026#39;, url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); } }   第7行显示 XMLHttpRequest 上的标志，必须设置该标志才能使用 Cookie 进行调用。默认情况下，调用是不在使用 Cookie 的情况下进行的。由于这是一个简单的 GET 请求，因此不会进行预检，但是浏览器将拒绝任何没有 Access-Control-Allow-Credentials 的响应：标头为true，指的是响应不会返回 web 页面的内容。\n上面的请求用下图可以表示\n这是客户端和服务器之间的示例交换：\n1 2 3 4 5 6 7 8 9 10  GET /resources/access-control-with-credentials/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Referer: http://foo.example/examples/credential.html Origin: http://foo.example Cookie: pageAccess=2   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:34:52 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Credentials: true Cache-Control: no-cache Pragma: no-cache Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 106 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain [text/plain payload]   上面第10行包含指向http://bar.other 上的内容 Cookie，但是如果 bar.other 没有以 Access-Control-Allow-Credentials:true 响应（下面第五行），响应将被忽略，并且不能使用网站返回的内容。\n请求凭证和通配符\n当回应凭证请求时，服务器必须在 Access-Control-Allow-Credentials 中指定一个来源，而不能直接写* 通配符\n因为上面示例代码中的请求标头包含 Cookie 标头，如果 Access-Control-Allow-Credentials 中是指定的通配符 * 的话，请求会失败。\n注意上面示例中的 Set-Cookie 响应标头还设置了另外一个值，如果发生故障，将引发异常（取决于所使用的API）。\n7.与跨域相关的请求头 下面会列出一些服务器跨域共享规范定义的 HTTP 标头，上面简单概述了一下，现在一起来认识一下，主要会介绍下面这些\n Access-Control-Allow-Origin Access-Control-Allow-Credentials Access-Control-Allow-Headers Access-Control-Allow-Methods Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Request-Headers Access-Control-Request-Method Origin  Access-Control-Allow-Origin Access-Control-Allow-Origin 是 HTTP 响应标头，指示响应是否能够和给定的源共享资源。Access-Control-Allow-Origin 指定单个资源会告诉浏览器允许指定来源访问资源。对于没有凭据的请求 *通配符，告诉浏览器允许任何源访问资源。\n例如，如果要允许源 https://mozilla.org 的代码访问资源，可以使用如下的指定方式\n1 2  Access-Control-Allow-Origin: https://mozilla.org Vary: Origin   如果服务器指定单个来源而不是*通配符，则服务器还应在 Vary 响应标头中包含该来源。\nAccess-Control-Allow-Credentials Access-Control-Allow-Credentials 是 HTTP 的响应标头，这个标头告诉浏览器，当包含凭证请求（Request.credentials）时是否将响应公开给前端 JavaScript 代码。\n这时候你会问到 Request.credentials 是什么玩意？不要着急，来给你看一下，首先来看 Request 是什么玩意，\n实际上，Request 是 Fetch API 的一类接口代表着资源请求。一般创建 Request 对象有两种方式\n 使用 Request() 构造函数创建一个 Request 对象 还可以通过 FetchEvent.request api 操作来创建  再来说下 Request.credentials 是什么意思，Request 接口的凭据只读属性指示在跨域请求的情况下，用户代理是否应从其他域发送 cookie。\n当发送的是凭证模式的请求包含 （Request.credentials）时，如果 Access-Control-Allow-Credentials 值为 true，浏览器将仅向前端 JavaScript 代码公开响应。\n1  Access-Control-Allow-Credentials: true   凭证一般包括 cookie、认证头和 TLS 客户端证书\n 当用作对预检请求响应的一部分时，这表明是否可以使用凭据发出实际请求。注意简单的 GET 请求不会进行预检。\n 可以参考一个实际的例子 https://www.jianshu.com/p/ea4\u0026hellip;\nAccess-Control-Allow-Headers Access-Control-Allow-Headers 是一个响应标头，这个标头用来响应预检请求，它发出实际请求时可以使用哪些HTTP标头。\n示例\n 自定义标头  这是 Access-Control-Allow-Headers 标头的示例。它表明除了像 CROS 安全列出的请求标头外，对服务器的 CROS 请求还支持名为 X-Custom-Header 的自定义标头。\n1  Access-Control-Allow-Headers: X-Custom-Header    多个标头  这个例子展示了 Access-Control-Allow-Headers 如何使用多个标头\n1  Access-Control-Allow-Headers: X-Custom-Header, Upgrade-Insecure-Requests    绕过其他限制  尽管始终允许使用 CORS 安全列出的请求标头，并且通常不需要在 Access-Control-Allow-Headers 中列出这些标头，但是无论如何列出它们都将绕开适用的其他限制。\n1  Access-Control-Allow-Headers: Accept   这里你可能会有疑问，哪些是 CORS 列出的安全标头？（别嫌累，就是这么麻烦）\n有下面这些 Accep、Accept-Language、Content-Language、Content-Type ，当且仅当包含这些标头时，无需在 CORS 上下文中发送预检请求。\nAccess-Control-Allow-Methods Access-Control-Allow-Methods 也是响应标头，它指定了哪些访问资源的方法可以使用预检请求。例如\n1 2  Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Methods: *   Access-Control-Expose-Headers Zs\n Cache-Control Content-Language Content-Type Expires Last-Modified Pragma  如果希望客户端能够访问其他标头，则必须使用 Access-Control-Expose-Headers 标头列出它们。下面是示例\n要公开非 CORS 安全列出的请求标头，可以像如下这样指定\n1  Access-Control-Expose-Headers: Content-Length   要另外公开自定义标头，例如 X-Kuma-Revision，可以指定多个标头，并用逗号分隔\n1  Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision   在不是凭证请求中，你还可以使用通配符\n1  Access-Control-Expose-Headers: *   但是，这不会通配 Authorization 标头，因此如果需要公开它，则需要明确列出\n1  Access-Control-Expose-Headers: *, Authorization   Access-Control-Max-Age Access-Control-Max-Age 响应头表示预检请求的结果可以缓存多长时间，例如\n1  Access-Control-Max-Age: 600   表示预检请求可以缓存10分钟\nAccess-Control-Request-Headers 浏览器在发出预检请求时使用 Access-Control-Request-Headers 请求标头，使服务器知道在发出实际请求时客户端可能发送的 HTTP 标头。\n1  Access-Control-Request-Headers: X-PINGOTHER, Content-Type   Access-Control-Request-Method 同样的，Access-Control-Request-Method 响应标头告诉服务器发出预检请求时将使用那种 HTTP 方法。此标头是必需的，因为预检请求始终是 OPTIONS，并且使用的方法与实际请求不同。\n1  Access-Control-Request-Method: POST   Origin Origin 请求标头表明匹配的来源，它不包含任何信息，仅仅包含服务器名称，它与 CORS 请求以及 POST 请求一起发送，它类似于 Referer 标头，但与此标头不同，它没有公开整个路径。例如\n1  Origin: https://developer.mozilla.org   ","title":"HTTP跨域请求"},{"link":"https://blog.dpf114.top/posts/6.http%E9%A6%96%E9%83%A8%E8%AF%B7%E6%B1%82%E6%A0%87%E5%A4%B4/","text":"HTTP协议的请求和响应报文中必定包含HTTP首部，只是我们平时在使用Web的过程中感受不到他。这篇文章我们一起来看看HTTP首部的结构和各字段的用法。\n1.HTTP报文首部 HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。\n1.1.HTTP请求报文 在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成。\nHTTP请求报文整体结构如下图：\n访问 http://hackr.jp 时，请求报文的首部信息如下：\n1 2 3 4 5 6 7 8 9 10 11  GET / HTTP/1.1 Host: hackr.jp Connection: keep-alive Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7 If-None-Match: \u0026#34;25e-4d2c3145df440-gzip\u0026#34; If-Modified-Since: Tue, 08 Jan 2013 08:53:29 GMT   1.2.HTTP响应报文 在响应中，HTTP报文由HTTP版本、状态码（数字或原因短语）、HTTP首部字段3部分组成。\n结构如下图：\n访问 http://hackr.jp/ 时，返回的响应报文的首部信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Date: Tue, 11 Aug 2020 07:34:33 GMT Server: Apache Last-Modified: Tue, 08 Jan 2013 08:53:29 GMT ETag: \u0026#34;25e-4d2c3145df440-gzip\u0026#34; Accept-Ranges: bytes Vary: Accept-Encoding,User-Agent Content-Encoding: gzip Content-Length: 379 Keep-Alive: timeout=15, max=100 Connection: Keep-Alive Content-Type: text/html   2.HTTP首部字段 2.1 HTTP首部字段传递重要信息 HTTP首部字段是构成HTTP报文的要素之一。在客户端与服务器间以HTTP协议进行通信过程中，无论请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。\n使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的 语言、认证信息等内容。\n2.2 HTTP首部字段结构 HTTP首部字段由首部字段名和字段值构成，中间用冒号“：”隔开。\n1  首部字段名：字段值   例如首部字段为Content-type，字符串text/html是字段值\n1  Content-Type：text/html   一个首部字段可以有多个值，用逗号隔开\u0026quot;,\u0026quot;\n1  Keep-Alive：timeout=15，max=100   若HTTP首部字段重复了会如何？\n 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时 会怎么样?这种情况在规范内尚未明确，根据浏览器内部处理逻辑 的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的 首部字段，而有些则会优先处理最后出现的首部字段。\n 2.3 4种HTTP首部字段类型 HTTP 首部字段根据实际用途被分为以下 4 种类型。\n1.通用首部字段(General Header Fields) 请求报文和响应报文两方都会使用的首部。\n2.请求首部字段（Request Header Fields) 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加 内容、客户端信息、响应内容相关优先级等信息。\n3.响应首部字段 (Response Header Fields) 从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加\n内容，也会要求客户端附加额外的内容信息。\n4.实体首部字段 (Entity Header Fields) 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更 新时间等与实体有关的信息。\n2.4 HTTP/1.1 首部字段一览 HTTP/1.1 规范定义了如下 47 种首部字段。\n1.通用首部字段 2.请求首部字段 3.响应首部字段 4.实体首部字段 2.5 非HTTP/1.1首部字段 在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定 义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。\n2.6 End-to-end 首部和 Hop-by-hop 首部 HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。\n1.端到端首部(End-to-end Header) 分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。\n2.逐跳首部(Hop-by-hop Header) 分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。\n在HTTP/1.1 首部字段中，除以下8个是逐跳首部外，其余全部属于端到端首部。\n1 2 3 4 5 6 7 8  Connection Keep-Alive Proxy-Authenticate Proxy-Authorization Trailer TE Transfer-Encoding Upgrade   3.HTTP/1.1 通用首部字段 通用首部字段是指，请求报文和响应报文双方都会使用的首部。\n3.1 Cache-Control 通过指定首部字段Cache-Control的指令能控制缓存的行为。指令的参数是可选的，多个指令之间通过“，”隔开。\n1  Cache-Control: private, max-age=0, no-cache   相关指令如下图：\n上面这个表格其实会有四种分类\n  可缓存性：no-cache、no-store、private、public。\n  缓存有效时间：max-age  、s-maxage、max-stale、min-fresh\n  重新验证并重新加载：must-revalidate、proxy-revalivate\n  其他：only-if-cached、no-transform\n  下面分别对以上内容进行详细介绍\nno-cache no-cache很容易和no-store混淆，一般会把no-cache认为是缓存，其实不是这样。\n使用no-cache指令的目的是为了防止从缓存中返回过期的资源，如下所示：\n1  Cache-Control: no-cache   举个例子你就明白了，No-Cache就相当于吃着碗里的，占着锅里的，如果锅里还有新的肉片，就先吃锅里的，如果锅里没有新的，就吃自己的，这里的锅里的就相当于源服务器产生的，碗里的就相当于是缓存的。\nno-store no-store才是真正意义上的不缓存，每次服务器接收到客户端的请求后，都会返回最新的资源给客户端。\n1  Cache-Control: no-store   private public max-age max-age可以用在请求或者响应中，当客户端发送带有max-age的指令时，缓存服务器就会判断自己缓存时间的数值和max-age的大小，如果比max-age小，那么缓存有效，可以继续给客户端返回缓存数据，如果比max-age大，那么缓存服务器将不能返回给客户端缓存的数据。\n1  Cache-Control: max-age=60   如果max-age=0，那么缓存服务器将会直接把请求转发到服务器。\n 注意：这个max-age的值是相对于请求时间的\n must-revalidate 表示缓存 一旦资源过期，缓存必须跟原始服务器进行有效性校验，只有在没有校验成功的情况下才能使用过期缓存。\n1  Cache-Control: must-revalidate   no-store、no-cache、must-revalidate、max-age可以一起看，下面是这四个标头的流程图\npublic public属性只出现在客户端响应中，表示响应可以被任何缓存所缓存。在计算机网络中，分为两种缓存，共享缓存和私有缓存。\n1  Cache-Control: public   private 当指定private指令后，响应只以特定的用户作为对象，这与public的用法相反，缓存服务器支队特定的客户端进行缓存，其他客户端发送过来的请求，缓存服务器则不会返回缓存。\n1  Cache-Control: private   s-maxage s-maxage指令的功能和max-age指令的功能相同，不同点之处在于s-maxage不能用于私有缓存，只能用于多用户使用的公共服务器，对于同一用户的重复请求和响应来说，这个指令没有任何作用。\n1  Cache-Control: s-maxage=60   min-fresh min-fresh只能出现在请求中，min-fresh要求缓存服务器返回min-fresh时间内的缓存数据。比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。\n1  Cache-control: min-fresh=60   max-stable max-stable只能出现在请求中，表示客户端会接收缓存数据，即使过期也照常接收。\n1  Cache-control: max-stable=60   如果指令未指定参数值，那么无论经过多久，客户端都会接收响应; 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。\nonly-if-cached 这个标头只能出现在请求中，使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。\n1  Cache-Control: only-if-cached   Proxy-revalidate proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。\n1  Cache-Control: proxy-revalidate   no-transform 使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。\n1  Cache-Control: no-transform   3.2 Connection HTTP协议使用TCP来管理连接方式，主要有两种连接方式，持久性连接和非持久性连接\n持久性连接 持久性连接指的是一次会话完成后，TCP连接并未关闭，第二次再次发送请求后，就不再需要建立TCP连接，而是可以直接进行请求和响应。它的一般表示形式如下\n1  Connection: Keep-Alive   从HTTP/1.1 开始，默认使用持久化连接。\nkeep-alive也是一个通用标头，一般Connection都会和keep-alive一起使用，keep-alive有两个参数，一个是timeout；另外一个是max，主要表现形式如下\n1 2  Connection: Keep-Alive Keep-Alive: timeout=5, max=1000    Timeout：指的是空闲连接必须打开的最短时间，也就是说这次连接请求时间不能少于5秒 max：指的是在连接关闭之前服务器所能收到的最大请求数。  非持久性连接 非持久性连接表示一次会话请求/响应后关闭连接的方式。HTTP/1.1 之前使用的连接都是非持久性连接，也即是\n1  Connection: close   3.3 Date Date是一个通用标头，它可以出现在请求标头和响应标头中，它的基本表示如下：\n1  Date: Wed, 12 Aug 2020 15:15:38 GMT   表示的是格林威治标准时间，这个时间比北京时间慢八个小时\n3.4 Pragma Pragma是HTTP/1.1 之前版本的历史遗留字段，仅作为与HTTP的向后兼容而定义，它的一般形式如下\n1  Pragma: no-cache   该首部字段属于通用首部字段，但只用在客户端发送的请求中。\n如果所有中间服务器如果都以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 即可，如果不是的话，就要包含两个字段，如下\n1 2  Cache-Control: no-cache Pragma: no-cache   3.5 Trailer 首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。一般用法如下\n1 2  Transfer-Encoding: chunked Trailer: Expires   以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 (分块长度 0 之后)出现了首部字段 Expires。\n3.6 Transfer-Encoding 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。\n HTTP/1.1 的传输编码方式仅对分块传输编码有效。􏱃􏰍 但是HTTP/2.0 就不再支持分块传输，而更有效的传输机制。 􏰬􏱈􏴯􏲢􏰴􏰆􏷓􏰸􏰹􏰉􏱊􏳞 􏴆􏳉􏱜􏴰􏲕􏲒􏲓􏰙􏴾􏵆􏰸􏰹􏱡􏱢􏰚\n 1  Transfer-Encoding: chunked   Transfer-Encoding的所有编码方式如下\n  chunked\n数据按照一系列块发送，在这种情况下，将省略Content-Length标头，并在每个块的开头，需要以十六进制填充当前块的长度，后面跟\\r\\n，然后是本身，然后是另一个\\r\\n。将大量数据发送到客户端并且在请求未被完全处理之前，分块处理很有用。例如，在传输大型图像时。分块响应看起来像下面这种\n  1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Content-Type: text/plain Transfer-Encoding: chunked 7\\r\\n Mozilla\\r\\n 9\\r\\n Developer\\r\\n 7\\r\\n Network\\r\\n 0\\r\\n \\r\\n     compress：由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel- Ziv-Welch 算法(LZW)。\n  deflate: 组合使用 zlib 格式(RFC1950)及由 deflate 压缩算法 (RFC1951)生成的编码格式。\n  gzip\n由文件压缩程序 gzip(GNU zip)生成的编码格式 (RFC1952)，采用 Lempel-Ziv 算法(LZ77)及 32 位循环冗余 校验(Cyclic Redundancy Check，通称 CRC)。\n  Identity：不执行压缩或不会变化的默认编码格式\n  3.7 Upgrade 首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。\n上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 Connection:Upgrade。\n对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。\n3.8 Via 使用首部字段 Via 是为了追踪客户端与服务器之间的请求/响应传输路径，避免请求循环以及能够识别请求/响应链中发送者的协议功能。Via字段由代理服务器添加（包括正向代理和反向代理），可以出现在请求标头和响应标头中。它用于追踪消息转发。如下图所示\nVia后面的1.1，1.0表示接受服务器上的HTTP版本，Via首部是为了跟踪路径经常和TRACE方法一起使用。\n3.9 Warning  注意：Warning 字段即将被弃用\n􏵵􏵶参考Warning (https://github.com/httpwg/http-core/issues/139) and Warning: header \u0026amp; stale-while-revalidate (https://github.com/whatwg/fetch/issues/913) 􏰎􏰏􏲕􏳾􏴁􏶽\n Warning 通用标头通常会告知用户一些与缓存有关问题的警告。\nHTTP/1.1 中定义了7种警告。如下图\n4.请求首部字段 请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。\n4.1 Accept HTTP请求标头会告知客户端能接收的MIME类型是什么\n MIME：MIME(Multipurpose Internet Mail Extensitions) 是描述消息内容类型的因特网标准。MIME消息能包括文本、图像、音频、视频以及其他应用程序专用的数据。\n MIME类型其实就是一系列消息内容类型的集合。MIME类型如下\n 文本文件：text/html􏴕、text/plain􏴕、text/css􏴕、application/xhtml+xml􏴕、application/xml\u0026hellip; 图片文件：image/jpeg、􏴕image/gif􏴕、image/png\u0026hellip; 视频文件：video/mpeg、􏴕video/quicktime\u0026hellip; 应用程序二进制文件：application/octet-stream􏴕、application/zip\u0026hellip;  比如，如果浏览器不支持PNG图片的显示，那Accept就不指定image/png，而指定可处理的类型。\n一般MIME类型也会和q 这个属性一起使用。q是什么？q表示一个权重，来看一个例子\n1  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8   这是什么意思呢？若想要给显示的媒体类型增加优先级，则使用q=来额外表示权重值（0~1），没有显示权重的时候默认值是1.0。\n4.2 Accept-Charset Accept-Charset表示客户端能接受的字符编码以及字符集的相对有限顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。\n1  Accept-Charset: iso-8859-5, unicode-1-1;q=0.8   4.3 Accept-Encoding Accept-Encoding 用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。\n1  Accept-Encoding: gzip, deflate   几个常用值：\n  gzip：由文件压缩程序 gzip(GNU zip)生成的编码格式\n  compress：由 UNIX 文件压缩程序 compress 生成的编码格式\n  deflate：组合使用 zlib 格式(RFC1950)及由 deflate 压缩算法 (RFC1951)生成的编码格式\n  identity：不执行压缩或默认编码方式\n  br：􏱋􏰒使用Brotli算法压缩，参考 􏳐（􏴒􏵧􏰉􏶋􏺌 􏱻 https://en.wikipedia.org/wiki/Brotli） 􏲂\n  *：默认值，可匹配任何编码\n  4.4 Accept-Language Accept-Language 用来告知服务器客户端能够处理的语言(中文或英文\u0026hellip;.)，以及语言的优先级，可一次指定多种语言，同样可以用q来指定优先级。\n1  Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3   4.5 Authorization Authorization用于向服务器发送认证用户代理的凭据，通常用在服务器以401未经授权状态和WWW-Authenticate标头响应之后。详解如下图\n4.6 Expect Expect 指示服务器需要满足特定的期望才能正确处理请求。如果服务器没有办法完成客户端所期望完成的事情并且服务端存在错误的话，会返回417 Expectation Failed。如果正常完成客户端锁期望的事情返回100（HTTP/1.1 规 范只定义了 100-continue）；如下\n1 2 3 4 5  PUT /somewhere/fun HTTP/1.1 Host: origin.example.com Content-Type: video/h264 Content-Length: 1234567890987 Expect: 100-continue   4.7 From From 用来告知服务器使用用户代理的用户的电子邮件地址。通常情况下，其使用目的是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。我们在使用代理的情况下，应尽可能包含From首部字段。例如\n1  From: webmaster@example.org   4.8 Host Host请求头指明了服务器的域名或IP地址，以及服务器监听的TCP端口号(可选)。如果没有指定端口后，会自动使用被请求服务的默认端口（比如请求一个HTTP的URL会被自动使用80端口）。\n1  Host: developer.mozilla.org   Host首部字段在 HTTP/1.1规范内唯一一个必须被包含在请求内的首部字段。\n4.9 If-Match If-Match 后面可以跟一大堆属性，形式像If-Match这种请求头称为条件请求，服务器接收到条件请求后，需要判定条件是否满足，只要条件请求为真，才会执行请求。\n类似的还有If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since\n对于GET或POST方法，服务器仅在与列出的ETag（响应标头）之一匹配时才会返回请求的资源。ETag后面做解释。对于像PUT和其他非安全方法，在这种情况下，它一般用于上传资源。\n下面是两种常见案例\n 对于GET和POST方法，会结合使用Range标头，它可以确保新发送请求的范围与上一个请求的资源相同。如果不匹配的话，会返回416响应。 对于其他方法，特别是PUT方法，If-Match可防止丢失更新，服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。反之，则返回状态码412 Precondition Failed 的响应。例如  1 2  If-Match: \u0026#34;bfc13a64729c4290ef5b2c2730249c88ca92d82d\u0026#34; If-Match: *   4.10 If-Modified-Since If-Modified-Since 是HTTP请求的一部分，只有在给定日期之后，服务端修改了请求所需要的资源，才会返回200 OK 的响应。如果在给定日期之后，服务端没有修改内容，响应会返回 304并且不带任何响应体。If-Modified-Since只能使用GET和HEAD请求。\n1  If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT   If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确 定。\n4.11 If-None-Match If-None-Match与􏸟􏱌􏰀􏰁􏰉􏰊􏲞 If-Match 􏰙􏳧􏰒􏲟􏱉的作用刚好相反。\n4.12 If-Range If-Range 也是条件请求，如果满足条件（If-Range的值和ETag的值或者更新时间一致），则会发出请求范围，否则将会返回全部资源。\n1  If-Range: Wed, 21 Oct 2015 07:28:00 GMT   4.13 If-Unmodified-Since If-Unmodified-Since 请求标头也是一个条件请求，服务器在给定时间之后没有进行修改时，服务器才会返回请求资源。如果在指定时间后发生了，则以状态码412 Precodition Failed 作为响应返回\n1  If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT   4.14 Max-Forwards Max-Forwards 一般用于TRANCE和OPTION方法，发送包含MAX-Forwards的首部字段时，每经过一个服务器，Max-Forwards的值就会-1，知道Max-Forwards为0时返回。Max-Forwards是一个十进制的整数值。\n1  Max-Forwards: 10   使用 HTTP协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。\n可以灵活使用首部字段 Max-Forwards 字段值为 0 ，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握\n4.15 Proxy-Authorization Proxy-Authorization 是属于请求与认证的范畴，不同于Authorization发生在客户端-服务器之间，Proxy-Authorization发生在代理服务器和客户端之间。它表示接收到从代理服务器发来的认证时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息。\n1  Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l   4.16 Range Range 指示服务器应返回文档指定部分的资源，可以一次请求一个 􏰀􏲃􏳬􏰛􏴠􏰞􏰟􏰠􏰨􏰥􏰦􏰰􏸧􏰛􏰜􏲍􏰆􏰙􏰐􏰑􏰉􏰾􏰿􏰄􏴸 Range 􏰓􏰥􏰦􏳾􏳔来返回多个部分，服务器会将这些资源返回各个文档中。如果服务器成功返回，那么将返回 􏲍􏰆􏰉􏰞􏰟􏰠􏲈􏲫􏳳􏴅􏰐􏰑􏰥􏰦􏹯􏳔􏰰􏸧􏱔􏰚􏰮􏰯􏰞􏰟􏰠􏵌􏵍􏰥􏰦􏰉􏰲􏵃􏲫􏰥􏰦 206 􏰧􏰨􏰷􏰮􏰯响应状态码，如果 Range 􏷻􏺩􏶀􏲓􏰉􏰞􏰟􏰠􏰥􏰦范围无效，服务器返回 416 Range Not Satisfiable 错误；􏺞􏺟􏰷􏰞􏰟􏰠􏳹􏰾􏰿􏺫􏸄\n1  Range: bytes=200-1000, 2000-6576, 19000-   4.17 Referer Referer 属性时请求标头的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用户处理。\n1  Referer: https://developer.mozilla.org/testpage.html   4.18 TE 字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段Accept-Encoding的功能很相像，但是TE是用于传输编码。\n1  TE: gzip, deflate;q=0.5   首部字段TE除指定传输编码之外，还可以指定伴随trailer 字段的分块传输编码的方式。应用后者时，只需把trailers复制给该字段值。\n1  TE: trailers, deflate;q=0.5   4.19 User-Agent 首部字段 User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。\n1  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36   5.响应首部字段 5.1 Accept-Ranges Accept-Ranges 响应标头有两个值可指定\n 当服务器能够处理客户端发送过来的请求时，使用bytes来指定 当服务器不能处理客户端发送过来的请求时，使用none来指定  1 2  Accept-Ranges: bytes Accept-Ranges: none   5.2 Age Age响应标头告诉客户端源服务器多久之前建立了响应，它的单位为秒，Age标头通常接近于0，如果是0则可能是从源服务器获取的，如果不是表示可能由代理服务器创建，那么Age的值表示的是缓存后的响应结果再次发起认证到认证完成的时间值。代理创建响应时不需加上标头Age。\n1  Age: 24   5.3 ETag ETag对于条件请求来说真的很重要。因为条件请求就是根据ETag的值进行匹配的，下面详细了解。\nETag响应头是特定版本的标识，它能使缓存变得高效并能节省带宽，因为如果换缓存内容未发生变更，Web服务器则不需要重新发送完整的路径。除此之外，ETag能够防止资源更新互相覆盖。\n如果给定的URL资源上的资源发生变更，必须生成一个新的ETag值，通过比较它们可以确定资源的两个表示形式是否相同。\nETag值有两种，一种是强Etag，一种是弱Etag\n 强Etag值，无论实体发生多么细微的变化都会改变其值，一般表示如下  1  ETag: \u0026#34;33a64df551425fcc55e4d42a148795d9f25f89d4\u0026#34;    弱Etag值，弱Etag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变Etag的值。这时，会在字段值最开始处附加W/  1  ETag: W/\u0026#34;0815\u0026#34;   5.4 Location Location响应标头表示URL需要重定向页面，它仅仅与3XX（重定向）或201（已创建）状态一起使用。下面是一个页面重定向的过程。\n使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。\nLocation和Content-Location是不一样的：Location表示目标的重定向。然而Content-Location表示发生内容协商时用于访问资源的直接URL，而无需进一步协商。Location是与响应相关联的标头，而Content-Location与返回的实体相关联。\n1  Location: /index.html   5.5 Proxyz-Authenticate Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。\n它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。\n1 2  Proxy-Authenticate: Basic Proxy-Authenticate: Basic realm=\u0026#34;Access to the internal site\u0026#34;   5.6 Retry-After Retry-After 告知客户端需要在多久之后重新发送请求，使用此标头主要有以下三种情况\n 当发送 503（服务不可用）请求时，这表示该服务预计无法使用多长时间。 当发送429（太多请求）时，这表示发出请求之前需要等待多长时间。 当发送重定向的响应时（3XX），这表示在发出重定向请求之前要求用户等待的最短时间。  字段值可以指定为具体的日期时间，也可以是创建响应之后所持续的秒数，例如\n1 2  Retry-After: Wed, 21 Oct 2015 07:28:00 GMT Retry-After: 120   5.7 Server Server标头包含有关原始服务器用来处理请求的软件信息。\n应该避免使用过于冗长和详细的Server值，因为他们可能会泄露内部实施细节，这可能会使攻击者容易地发现并利用已知的安全漏洞。例如下面写法\n1  Server: Apache/2.2.17 (Unix)   5.8 Vary Vary 响应标头确定如何匹配响应标头，以决定是使用缓存还是从原始服务器请求一个新的响应。\n1  Vary: Accept-Language   例如下图使用的是Accept-Language字段且字段值相同时，直接从缓存返回响应，反之从新请求响应。\n5.9 www-Authenticate www-Authenticate 响应标头定义了应用用于获得对资源的访问权限的身份验证方法。 www-Authenticate标头与401未授权的响应一起发送。它的一般表示形式如下：\n1 2  1 WWW-Authenticate: Basic 2 WWW-Authenticate: Basic realm=\u0026#34;Access to the staging site\u0026#34;, charset=\u0026#34;UTF-8\u0026#34;   5.10 Access-Control-Allow-Origin 一个返回的HTTP标头可能会具有Access-Control-Allow-Origin，Access-Control-Allow-Origin 指定一个来源，它告诉浏览器允许该来源进行访问。如果Access-Control-Allow-Origin对应的值是*的话允许任何来源访问。例如，要允许源https://mozilla.org 的代码访问资源，可以指定：\n1 2  Access-Control-Allow-Origin: https://mozilla.org Vary: Origin   如果服务器指定单个来源不是*的话，则服务器还应该在Vary响应标头包含Origin,以向客户端指示服务器响应将根据原始请求标头的值。\n6. 实体首部字段 实体标头用于HTTP请求和响应中，例如Content-Length，Content-Language，Content-Encoding的标头是实体标头。实体标头不局限于请求标头或者响应标头，下面例子中，Content-Length是一个实体标头，但是却出现在了请求报文中。\n1 2 3 4  POST /myform.html HTTP/1.1 Host: developer.mozilla.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 Content-Length: 128   6.1 Allow Allow用于列出HTTP请求资源请求所支持的方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。\n1  Allow: GET, POST, HEAD   6.2 Content-Encoding Content-Encoding 会告知客户端服务器对实体的主体部分选 用的内容编码方式。\n1  Content-Encoding: gzip   6.3 Content-Language Content-Language 会告知客户端，实体主体使用的自然语言 (指中文或英文等语言)。\n1  Content-Language: zh-CN   6.4 Content-Length Content-Length 表明了实体主体部分的大小(单位是字节)。\n1  Content-Length: 3000   6.5 Content-Location Content-Location与Location相对应。\nLocation和Content-Location是不一样的，Location表示重定向的RUL，而Content-Location表示用于访问资源的直接URL，以后无需进行进一步的内容协商。Location是与响应关联的标头，而Content-Location是与返回的数据相关联的标头。\n6.6 Content-MD5 客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较。\n1  Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==   首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。\n6.7 Content-Range Content-Range针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。\n1  Content-Range: bytes 5001-10000/10000   6.8 Content-Type Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样使用，表示服务器能够响应的媒体类型。\n1  Content-Type: text/html; charset=UTF-8   6.9 Expires 1  Expires: Wed, 04 Jul 2012 08:26:05 GMT   首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会判断是否把缓存返回客户端。\n源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。\n但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。\n6.10 Last-modified 首部字段 Last-Modified 指明资源最终修改的时间。\n1  Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT   7.为Cookie服务的首部字段 Cookie的工作机制是用户识别及状态管理。Web 网站为了管理用户的 状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接 着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。\n调用Cookie时，由于可校验Cookie的有效期，以及发送方的域、路径、协议等信息，所以正规发布的Cookie内的数据不会因来自其他Web站点和攻击者的攻击而泄露。\n至 2013 年 5 月，Cookie 的规格标准文档有4 种。目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。下面内容对目前使用最为广泛普及的标准进行说明。\n为Cookie服务的首部字段\n7.1 Set-Cookie 1  Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31   当服务器准备开始管理客户端的状态时，会事先告知各种信息。\nSet-Cookie 的相关属性说明如下图\nexpires属性\nCookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。\n省略expires属性时，有效期为一次会话。\n一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。\npath属性\nCookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱 有期待。\ndomain属性\n通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，www.example.com 或 www2.example.com 等都可以发送 Cookie。\n因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。\nsecure属性\nCookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。\n1  Set-Cookie: name=value; secure   如上例子仅在请求协议是https时才会进行Cookie回收。\nHttpOnly 属性\nCookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击(Cross-site scripting，XSS)对 Cookie 的信息窃取。\n1  Set-Cookie: name=value; HttpOnly   通过上述设置，使用JavaScript的document.cookie无法获取对应cookie。可防止xss攻击。\n8.其他首部字段 HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应 用上，会出现各种非标准的首部字段。\n1.X-Frame -Options 1  X-Frame-Options: DENY   首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容 在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防 止点击劫持(clickjacking)攻击。\n首部字段 X-Frame-Options 有以下两个可指定的字段值。\n  DENY :拒绝\n  SAMEORIGIN :仅同源域名下的页面(Top-level-browsing- context)匹配时许可。(比如，当指定 http://hackr.jp/sample.html 页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被 允许可加载该页面，而 example.com 等其他域名的页面就不行 了)\n  2.X-XSS-Protection 1  X-XSS-Protection: 1   首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器 XSS 防护机制的开关。\n首部字段 X-XSS-Protection 可指定的字段值如下。\n 0 :将 XSS 过滤设置成无效状态 1 :将 XSS 过滤设置成有效状态  3.DNT 1  DNT: 1   首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简 称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。\n首部字段 DNT 可指定的字段值如下。\n  0 :同意被追踪\n  1 :拒绝被追踪\n  4.P3P 1  P3P: CP=\u0026#34;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa   首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P(The Platform for Privacy Preferences，在线隐私偏好平台)技术，可以让 Web 网站上 的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的 目的。\n","title":"HTTP协议(六)HTTP首部(请求标头)"},{"link":"https://blog.dpf114.top/posts/5.%E4%B8%8Ehttp%E5%8D%8F%E4%BD%9C%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8/","text":"一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。\n1.用单台虚拟机实现多个域名 HTTP/1.1规范允许一台HTTP服务器搭建多个Web站点。这是因为利用了虚拟主机(Virtual Host，又称虚拟服务器)的功能。即使物理层面只有一台服务器，但只要使用虚拟机的功能，则可以假想已具有多台服务器。\n客户端使用HTTP协议访问服务器时，会经常采用域名访问，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。\n所以，如果一台服务器内托管了多个域名，当收到请求时就需要弄清楚究竟是哪个域名。因此在发送HTTP请求时，必须在Host首部完整指出主机名或域名的URI。\n2.通信转发程序：代理、网关、隧道 HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发 的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。\n这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接受从那台服务器发送的响应再转发给客户端。\n2.1.代理 代理是一种由转发功能的应用程序，它扮演了位于服务器和客户端\u0026quot;中间人\u0026quot;的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。\n代理服务器的几个特点：\n 代理不会改变请求的URI，会直接发送给前方持有资源的目标服务器 代理转发请求或响应时，会追加写入Via首部信息（标记处经过的主机信息）  使用代理的目的：\n 利用缓存减少网络带宽的流量 租住内部对特定网站的访问控制 获取访问日志  代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一 种是是否会修改报文。\n2.1.1 缓存代理 代理转发响应时，缓存代理(Caching Proxy)会预先将资源的副本 (缓存)保存在代理服务器上。\n当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。\n2.1.2 透明代理 转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理 (Transparent Proxy)。反之，对报文内容进行加工的代理被称为非 透明代理。\n2.2.网关 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源服务器一样对请求进行处理，有时客户端都不会察觉。\n百度百科定义：\n大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关（Gateway） [1] 就是一个网络连接到另一个网络的“关口”。也就是网络关卡。\n图:利用网关可以由 HTTP 请求转化为其他协议通信\n网关的工作机制和代理十分相似。最大的不同是网关能使通信线路上的服务器提供非HTTP协议服务。\n利用网关能提高通信的安全性：可以在客户端与网关通信之间的通信线路上加密以确保连接的安全。例如，网关可以连接数据库，使用SQL语句查询数据。\n2.3.隧道 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。\n隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等 加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。\n隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。\n3.保存资源的缓存 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。\n缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。\n缓存服务器的优点：\n 避免重复从源服务器转发资源 避免源服务器重复处理相同的请求 减少通信时间和通信流量  3.1 缓存的有效期 缓存既然是资源的副本，那么就必须有一个有效时间，当有效时间一过或者源服务器资源更新那么就必须重新请求。\n3.2 客户端的缓存 缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件 (Temporary Internet File)。\n浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。\n另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。\n","title":"HTTP协议(五)与HTTP协作的Web服务器"},{"link":"https://blog.dpf114.top/posts/4.%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84http%E7%8A%B6%E6%80%81%E7%A0%81/","text":"HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现错误等工作。\n1.状态码类别 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结 果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出 现了错误。\n数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。\n2.常用状态码 2.1. 2XX  200 OK：表示从客户端发来的请求在客户端被正常处理了 204 NO Content：请求处理成功但没有资源返回 206 Partial Content：对一部分资源的请求   在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回;而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体 作为响应返回(即在响应中只返回首部，不会返回实体的主体部 分)。\n 2.2. 3XX 3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。\n 301 Moved Permanently：永久性重定向。 302 Found：临时重定向（我们平时讲的重定向） 303 See Other：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 304 Not Modified：资源已经找到，但未符合请求。 307 Temporary Redirect：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。  2.3. 4XX 4XX 的响应结果表明客户端是发生错误的原因所在。\n 400 Bad Request：请求报文中存在语法错误或与请求接口所需内容不匹配。 401 Unauthorized：表示发送的请求需要通过HTTP认证（Basic认证、DIGEST认证）的认证信息。若之前已经发送过1次请求，则表示认证失败 403 Forbidden：表示请求的资源被服务器拒绝了（没有对应权限） 404 Not Found：没有找到对应资源（请求路径有问题..）  2.4. 5XX 5XX 的响应结果表明服务器本身发生错误。\n 500 Internal Server Error：表示服务器请求时发生错误，有bug或某些临时故障。 503 Service Unavailable：表示服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。  ","title":"HTTP协议(四)返回结果的HTTP状态码"},{"link":"https://blog.dpf114.top/posts/3.http%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84http%E4%BF%A1%E6%81%AF/","text":"HTTP通信过程包括从客户端发往服务器端的请求及从服务器返回客户端的请求。\n1.HTTP报文 用于HTTP协议交互的信息称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应段（服务器端）的叫做响应报文。HTTP 报文本身是由多行(用 CR+LF 作换行符)数据构成的字符串文 本。\nHTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行(CR+LF)来划分。通常，并不一定要有报文主体。\n2.请求报文和响应报文结构 整体结构如下：\n下图是我的个人博客请求及响应报文结构。\n请求报文和响应报文的首部内容由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。\n请求行 包含请求的方法，请求的URI和HTTP版本\n状态行 包含表明响应结果的状态码，原因短语和 HTTP 版本。\n首部字段 包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是:通用首部、请求首部、响应首部和实体首部。\n其他 可能包含 HTTP 的 RFC 里未定义的首部(Cookie 等)。\n3.编码提升传输速率 HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效处理大量访问请求。但是编码操作都是由计算机完成，因此可能会消耗更多的CPU等资源。\n3.1.报文主体和实体主体的差异   报文（message）\n是HTTP通信中的基本单位，由 8 位组字节流(octet sequence， 其中 octet 为 8 个比特)组成，通过 HTTP 通信传输。\n  实体（entity）\n作为请求或响应的有效载荷数据(补充项)被传输，其内容由实体首部和 实体主体组成。\n  HTTP 报文的主体用于传输请求或响应的实体主体。\n==通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体 主体的内容发生变化，才导致它和报文主体产生差异。==\n3.2.压缩传输的内容编码 向待发送有哦建内添加附件时，为了使邮件容量变小，我们会用ZIP压缩文件后再添加附件发送。HTTP协议中有一种被称为内容编码的功能也能进行类似操作。\n内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。\n常用的内容编码有以下几种：\n gzip(GNU zip) compress(UNIX 系统的标准压缩) deflate(zlib) identity(不进行编码)  3.3.分割发送的分块传输编码 在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前， 浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。\n这种把实体主体分块的功能称为分块传输编码(Chunked Transfer Coding)。\n分块传输编码会将实体主体分成多个部分(块)。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。\n使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。\n4.发送多种数据的多部分对象集合 发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME(Multipurpose Internet Mail Extensions，多用途因特网邮 件扩展)机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。在 MIME 扩展中会使用一 种称为多部分对象集合(Multipart)的方法，来容纳多份不同类型的数据。\n相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主 体内可含有多类型实体。通常是在图片或文本文件等上传时使用。\n多部分对象集合包含的对象如下：\n  multipart/form-data\n在 Web 表单文件上传时使用\n  1 2 3 4 5 6 7 8 9  Content-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\u0026#34;field1\u0026#34; Joe Blow --AaB03x Content-Disposition: form-data; name=\u0026#34;pics\u0026#34;; filename=\u0026#34;file1.txt\u0026#34; Content-Type: text/plain ...(file1.txt的数据)... --AaB03x--     multipart/byteranges\n状态码 206(Partial Content，部分内容)响应报文包含了多个范围的内容时使用。\n HTTP/1.1 206 Partial Content\rDate: Fri, 13 Jul 2012 02:45:26 GMT\rLast-Modified: Fri, 31 Aug 2007 02:02:20 GMT\rContent-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\r--THIS_STRING_SEPARATES\rContent-Type: application/pdf Content-Range: bytes 500-999/8000\r...(范围指定的数据)... --THIS_STRING_SEPARATES Content-Type: application/pdf Content-Range: bytes 7000-7999/8000\r...(范围指定的数据)... --THIS_STRING_SEPARATES--\r在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。\n使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行之前插入“\u0026ndash;”标记(例如:- -AaB03x、\u0026ndash;THIS_STRING_SEPARATES)，而在多部分对象集合对 应的字符串的最后插入“\u0026ndash;”标记(例如:\u0026ndash;AaB03x\u0026ndash;、\u0026ndash; THIS_STRING_SEPARATES\u0026ndash;)作为结束。\n多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可 以在某个部分中嵌套使用多部分对象集合。\n  5.获取部分内容的范围请求 以前我们的网速没有现在那么快，当前，下载一个稍微大一点的文件就很吃力了。如果下载过程中遇到网络中断的情况，那就必须重新下载；为了解决上述问题，需要一种可恢复机制。所谓恢复是指能从之前下载中断出恢复下载。\n要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请 求叫做范围请求(Range Request)。\n对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。\n执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。\nbyte 范围的指定形式如下:\n 5001~10000字节  1  Range: bytes=5001-10000    从 5001 字节之后全部的  1  Range: bytes=5001-    从一开始到 3000 字节和 5000~7000 字节的多重范围  1  Range: bytes=-3000, 5000-7000   针对范围请求，响应会返回状态码为 206 Partial Content 的响应报 文。另外，对于多重范围的范围请求，响应会在首部字段 Content- Type 标明 multipart/byteranges 后返回响应报文。\n如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。\n","title":"HTTP协议(三)HTTP报文中的HTTP信息"},{"link":"https://blog.dpf114.top/posts/2.%E7%AE%80%E5%8D%95%E7%9A%84http%E5%8D%8F%E8%AE%AE/","text":"1.HTTP协议用于客户端和服务端之间的通信 HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。\nHTTP通信时一定有一个客户端一个服务端(有时候客户端和服务端角色可能互换)，客户端用于发送请求，服务端用于回复响应。\n HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返 回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有 接收到请求之前不会发送响应。\n 2.HTTP是不保存状态的协议 HTTP是一种不保存状态的协议(HTTP/1.0)，即无状态协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快处理大量事务，确保协议的可伸缩性。\nHTTP/1.1引入了Cookie用于管理请求状态。\n3.告知服务器意图的HTTP方法 1.GET方法 GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回;\n2.POST方法 POST方法用来传输实体的主体(例如登录注册用来传输用户实体)\n虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。\n3.PUT方法 PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。\n但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST(REpresentational State Transfer，表征状态转移)标准的同类 Web 网站，就可能会开放使用 PUT 方法。\n4.DELETE方法 DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。\n但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。\n5.HEAD方法 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头\n6.OPTIONS方法 OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。\n7.TRACE TRACE 方法用于回显服务器收到的请求，主要用于测试或诊断。\n8.CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器(请求通过代理服务器建立通信)。\nCONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL(Secure Sockets Layer，安全套接 层)和 TLS(Transport Layer Security，传输层安全)协议把通信内容 加 密后经网络隧道传输。\nHTTP/1.0 和 HTTP/1.1 支持的方法对比如下表：\n在这里列举的众多方法中，LINK 和 UNLINK 已被 HTTP/1.1 废弃，不 再支持。\n4.持久连接和管线化 HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。在容量很小的传输中问题不大；但是传输容量一大，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。\n为了解决上面提到TCP连接问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接(HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse)的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。在 HTTP/1.1 中，所有的连接默认都是持久连接\n 持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。\n 持久连接使得多数请求以管线化(pipelining)方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待 响应了。\n5.使用 Cookie 进行状态管理 HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。\n假设要求登录认证的 Web 页面本身无法进行状态的管理(不记录已 登录的状态)，那么每次跳转新页面不是要再次登录，就是要在每次 请求报文中附加参数来管理登录状态。\n不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然 可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是 因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。\n保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。\nCookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。\n服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\n 没有 Cookie 信息状态下的请求：   第 2 次以后(存有 Cookie 信息状态)的请求  \r在现在的主流项目中(前后端分离)一般不用cookie进行状态管理，一般将用户的信息(token)存储在Local Storage或者Session Storage中。\n","title":"HTTP协议(二)简单的HTTP协议"},{"link":"https://blog.dpf114.top/posts/1%E4%BA%86%E8%A7%A3web%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","text":"1.使用HTTP协议访问Web 你知道当我们在网页浏览器(Web browser)的地址栏中输入 URL时，Web 页面是如何呈现的吗? 如上图所示我们在浏览器(客户端)的地址栏输入URL(地址)时，浏览器会根据对应的地址向服务器获取对应的resource(资源)等信息，从而显示出Web页面。\nWeb 使用一种名为 HTTP(HyperText Transfer Protocol，超文本传输协议) 的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说，Web 是建立在 HTTP 协议上通 信的。\n2.HTTP的诞生 1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。\n最初设想的基本理念是:借助多文档之间相互关联形成的超文本 (HyperText)，连成可相互参阅的 WWW(World Wide Web，万维网)。\n现在已提出了 3 项 WWW 构建技术，分别是:\n 把 SGML(Standard Generalized Markup Language，标准通用标记语言)作为页面的文本标记语言的 HTML(HyperText Markup Language，超文本标记语言); 作为文档传递协议的 HTTP ; 指定文档所在地址的 URL(Universal Resource Locator)   WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。\n HTTP各个版本\nHTTP/0.9 HTTP于1990年问世，但是的HTTP并没有作为正式的标准被建立。这时的HP其实还有HTTP/1.0之前版本的意思，因此被称为HTTP/0.9。\nHTTP/1.0 HTTP正是作为标准被公布，是在1996年的五月版本被命名为HTTP1.0N记载于RFC1945，虽说是初七标准，但该协议标准至今仍被广泛使用，在服务器端。\nHTTP/1.1 1997年1月公布的HTTP1.1是目前主流的HTTP协议版本，当初的标准是RFC2068之后发布的修订版RFC2616是当前的最新版本\nHTTP/2.0 在2010年到2015年，谷歌通过实践了一个实验性的SPDY协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输，SPDY成为了HTTP/2协议的基础。 在2015年5月正式标准化后，HTTP/2取得了极大的成功，在2016年7月前，8.7%的站点已经在使用它，代表超过68%的请求。高流量的站点最迅速的普及，在数据传输上节省了可观的成本和支出。\n3.网络基础 TCP/IP 3.1.TCP/IP协议族 计算机与网络设备要相互通信，双方就必须基于相同的方法。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议(protocol)。\t通常使用的网络(包括互联网)是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。\n3.2.TCP/IP分层管理 TCP/IP协议族里重要的一点就是分层。TCP/IP协议族按层次分别为一下四层：应用层、传输层、网络层和数据链路层。\n分层的好处：\n 某一个应用需要改变时不需要把整个应用替换掉，只需要把需要变动的层替换掉即可。分层之后，设计变得相对简单了，处于某一层的应用只需要考虑自己这一层的任务，不需要考虑其他层。\n 3.2.1各层的作用 1.应用层 应用层决定了向用户提供应用服务时通信的活动。\nTCP/IP 协议族内预存了各类通用的应用服务。比如，FTP(File Transfer Protocol，文件传输协议)和 DNS(Domain Name System，域名系统)服务就是其中两类。 HTTP 协议也处于该层。\n2.传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议:TCP(Transmission Control Protocol，传输控制协议)和 UDP(User Data Protocol，用户数据报协议)。\nTCP和UDP的异同：\n TCP提供面向连接的，可靠的数据传输服务。 UDP提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。\n 3.网络层（又名网络互连层） 网络层是用来处理在网络上流动的数据包。数据包是传输的最小数据单位。该层规定了通过怎样的路径（所谓传输路线）到达对方计算机，并把数据包传给对方。\n与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路径。\n4.链路层（又名数据链路层，网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card，网络适配器，即网卡)、光纤等物理可见部分。硬件上的范畴。\n3.2.2.TCP/IP通信传输流 以HTTP举例各层简易传输流程如下图： 利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。\n具体传输流程：\n 首先作为发送端的客户端在应用层（HTTP协议）发出一个想看某个Web页面的HTTP请求。 接着，为传输方便，在传输层（TCP协议）把应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号转发给网络层 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序网上层传达，一直应到应用层。当传输到应用层，才算真正接收到由客户端发送过来的HTTP请求。  ** 带首部的传输流程如下图： 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，没经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装。\n4.与HTTP关系密切的协议 与HTTP关系密切的协议有三个：IP、TCP、DNS。\n4.1.负责传输的IP协议 按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol这个名字可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到IP协议。TCP/IP协议族中的IP指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。\nIP协议的作用是把各种数据包传送给对方。而要保证确实传到对方那里，则需要满足各类条件。其中两个重要的条件时IP地址和MAC地址。\nIP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。\n使用ARP协议凭借MAC地址进行通信： IP间的通信依赖MAC地址。在网络上，通信的双方在同一局域网（LAN）内的情况很少，通常是经过多台计算机和网络设备中转才能连接到对方。而进行中转时，会利用下一站中转设备的MAC地址来搜索中转目标。这时会采用ARP协议（Address Resource Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。\nARP通信如下图： 4.2.确保可靠性的TCP协议 按层次分，TCP位于传输层，提供可靠的字节流服务。\n所谓的字节流服务(Byte Stream Service)是指，为了方便传输，将大块数据分割成以报文段(segment)为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。\n怎么确保数据能够到达对方？ TCP协议采用三次握手策略确保数据能准确送达目标。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。\n握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize) 和ACK(acknowledgement)。\n三次握手如下图：  第一次握手：发送端发送一个带有SYN标志的数据包给对方 第二次握手：接受端接收后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 第三次握手：发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。  4.3.负责域名解析的DNS服务 DNS(Domain Name System)服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。 5.各种协议与HTTP协议的关系 6.URI和URL  URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\tURI 用字符串标识某一互联网资源，而 URL 表示资源的地点(互联网上所处的位置)。可见 URL 是 URI 的子集。 URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。  绝对 URI 的格式：  协议方案名\t：使用http:或https:协议名称，不区分字母大小写，最后一个冒号（:） 登录信息(可选)：指定用户名和密码作为从服务器端获取资源时必要的登录信息。 服务器地址：服务器地址可以是域名(erunn.xyz)，或者是192.169.1.1这类IP地址。 服务器端口号：指定连接的网络端口号。此项也是可选性，若省略则自动使用默认端口号 带层次的文件路径：指定服务器上的文件路径来定位特指的资源。这与Unix系统的文件目录结构相似。 查询字符串(可选)：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。 片段表示符(可选)：使用片段标识符通常可标记已获取资源中的子资源。但在 RFC 中并没有明确规定其使用方法。   并不是所有的应用程序都符合 RFC。 有一些用来制定 HTTP 协议技术标准的文档，它们被称为RFC(Request for Comments，征求修正意见书)。\n ","title":"HTTP协议(一)了解web及网络基础"},{"link":"https://blog.dpf114.top/posts/springmvc/","text":"1.什么是SpringMVC?简单的解释一下你对SpringMVC的理解？ SpringMVC是一个基于java实现了MVC设计模式的一个轻量级web框架。通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。\n2.SpringMVC的流程  （1）用户发送请求至前端控制器DispatcherServlet； （2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle； （3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； （4）DispatcherServlet 调用 HandlerAdapter处理器适配器； （5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)； （6）Handler执行完成返回ModelAndView； （7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet； （8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析； （9）ViewResolver解析后返回具体View； （10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） （11）DispatcherServlet响应用户。  3、Springmvc的优点:  （1）可以支持各种视图技术,而不仅仅局限于JSP； （2）与Spring框架集成（如IoC容器、AOP等）； （3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。 （4） 支持各种请求资源的映射策略。  4、Spring MVC的主要组件(六大组件)？ （1）前端控制器 DispatcherServlet（不需要程序员开发）\n作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。\n（2）处理器映射器HandlerMapping（不需要程序员开发）\n作用：根据请求的URL来查找Handler\n（3）处理器适配器HandlerAdapter\n注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。\n（4）处理器Handler（需要程序员开发）\n（5）视图解析器 ViewResolver（不需要程序员开发）\n作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）\n（6）视图View（需要程序员开发jsp）\n5.post请求时怎么处理乱码，get请求又是怎么处理乱码 1.post请求:通过在web.xml文件中配置一个CharacterEncodingFilter过滤器，设置成utf-8\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;   2.get请求：\n①修改tomcat配置文件添加编码与工程编码一致，如下：\n1  \u0026lt;ConnectorURIEncoding=\u0026#34;utf-8\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; redirectPort=\u0026#34;8443\u0026#34;/\u0026gt;    ②另外一种方法对参数进行重新编码：\nString userName = new String(request.getParamter(\u0026ldquo;userName\u0026rdquo;).getBytes(\u0026ldquo;ISO8859-1\u0026rdquo;),\u0026ldquo;utf-8\u0026rdquo;)\nISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n6.常用注解  @RequestBody：作用在参数上接受json数据  1 2 3 4  @PostMapping(\u0026#34;/test\u0026#34;) public String test(@RequestBody Object obj){ }    @ResponseBody：作用在方法上返回json数据  1 2 3 4 5  @PostMapping(\u0026#34;/test\u0026#34;) @ResponseBody public String test(){ }    @RequestMapping(get/post/delete/put) @RequestParam 用在方法的参数前面(与请求方法中的参数名相匹配)   相关参数：\nvalue：值 即请求参数的参数名 required:该参数是否为必须，默认为true defauValue：请求参数的默认值\n  @PathVariable：获取路径参数  1 2 3 4  @GetMapping(\u0026#34;/usr/{userId}\u0026#34;) public String login(@PathVariable(\u0026#34;userId\u0026#34;) String userId){ .... }    @ControllerAdvice：统一处理异常 @ExceptionHandler：用在方法上表示遇到这个异常就执行以下方法。  7.数据校验 普通校验  依赖  1 2 3 4 5 6 7 8 9 10  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.8.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    web.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;spring-mvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:*.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;spring-mvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterEncoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterEncoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt;    springmvc配置文件中配置  1 2 3 4 5 6 7  \u0026lt;context:component-scan base-package=\u0026#34;com.dpf\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 校验bean --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\u0026#34; id=\u0026#34;validatorFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;providerClass\u0026#34; value=\u0026#34;org.hibernate.validator.HibernateValidator\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注解支持 --\u0026gt; \u0026lt;mvc:annotation-driven validator=\u0026#34;validatorFactoryBean\u0026#34;/\u0026gt;    实体类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public class User { @NotNull private Integer id; @NotNull @Size(min = 2,max = 10) private String name; @Email private String email; @Max(150) private Integer age; public User(){ } public User(@NotNull Integer id, @NotNull @Size(min = 2, max = 10) String name, @Email String email, @Max(150) Integer age) { this.id = id; this.name = name; this.email = email; this.age = age; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } }    controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @RestController public class UserController { /** * @Validated 表示 user 中定义的校验规则将会生效 * BindingResult 表示出错信息，如果这个变量不为空，表示有错误，否则校验通过 * @param user * @param result * @return */ @PostMapping(\u0026#34;/add\u0026#34;) public Object addUser(@Validated User user,BindingResult result){ if(result!=null){ //校验未通过，获取所有的异常信息并展示出来  List\u0026lt;ObjectError\u0026gt; allErrors = result.getAllErrors(); for (ObjectError allError : allErrors) { System.out.println(allError.getObjectName()+\u0026#34;:\u0026#34;+allError.getDefaultMessage()); } } return user; } }   自定义错误消息  在resource下添加文件errorMessages.properties  user.id.notnull=id 不能为空\ruser.name.notnull=name 不能为空\ruser.name.length=name 最小长度为 2 ，最大长度为 10\ruser.email.error=email 地址非法\ruser.age.error=年龄不能超过 150\r springmvc配置文件如下  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!-- 校验bean --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\u0026#34; id=\u0026#34;validatorFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;providerClass\u0026#34; value=\u0026#34;org.hibernate.validator.HibernateValidator\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;validationMessageSource\u0026#34; ref=\u0026#34;bundleMessageSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 自定义错误消息 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.context.support.ReloadableResourceBundleMessageSource\u0026#34; id=\u0026#34;bundleMessageSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;basenames\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;classpath:errorMessages\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;cacheSeconds\u0026#34; value=\u0026#34;300\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注解支持 --\u0026gt; \u0026lt;mvc:annotation-driven validator=\u0026#34;validatorFactoryBean\u0026#34;/\u0026gt;   校验注解  @Null 被注解的元素必须为 null @NotNull 被注解的元素必须不为 null @AssertTrue 被注解的元素必须为 true @AssertFalse 被注解的元素必须为 false @Min(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注解的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注解的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注解的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注解的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注解的元素必须是一个过去的日期 @Future 被注解的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注解的元素必须符合指定的正则表达式 @NotBlank(message =) 验证字符串非 null，且长度必须大于0 @Email 被注解的元素必须是电子邮箱地址 @Length(min=,max=) 被注解的字符串的大小必须在指定的范围内 @NotEmpty 被注解的字符串的必须非空 @Range(min=,max=,message=) 被注解的元素必须在合适的范围内  8.全局异常处理  @ControllerAdvice 表示这是一个增强版的 Controller，主要用来做全局数据处理 @ExceptionHandler 表示这是一个异常处理方法，这个注解的参数，表示需要拦截的异常，参数为 Exception 表示拦截所有异常，这里也可以具体到某一个异常，如果具体到某一个异常，那么发生了其他异常则不会被拦截到。 异常方法的定义，和 Controller 中方法的定义一样，可以返回 ModelAndview，也可以返回 String 或者 void  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @ControllerAdvice public class MyException { /** * @ExceptionHandler(需要处理的异常.class) * @param e * @return */ @ExceptionHandler(Exception.class) public ModelAndView myexception(Exception e){ ModelAndView error = new ModelAndView(\u0026#34;error\u0026#34;); error.addObject(\u0026#34;error\u0026#34;, e.getMessage()); return error; } }    当异常方法自定义完，对应方法抛出对应异常就会交给自定义异常方法处理。\n 9.文件上传 SpringMVC 中对文件上传做了封装，我们可以更加方便的实现文件上传。从 Spring3.1 开始，对于文件上传，提供了两个处理器：\n CommonsMultipartResolver StandardServletMultipartResolver  第一个处理器兼容性较好，可以兼容 Servlet3.0 之前的版本，但是它依赖了 commons-fileupload 这个第三方工具，所以如果使用这个，一定要添加 commons-fileupload 依赖。\n第二个处理器兼容性较差，它适用于 Servlet3.0 之后的版本，它不依赖第三方工具，使用它，可以直接做文件上传。\nCommonsMultipartResolver做文件上传  依赖  1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;    springmvc配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;bean class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34; id=\u0026#34;multipartResolver\u0026#34;\u0026gt; \u0026lt;!--默认的编码--\u0026gt; \u0026lt;property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;!--上传的总文件大小--\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSize\u0026#34; value=\u0026#34;1048576\u0026#34;/\u0026gt; \u0026lt;!--上传的单个文件大小--\u0026gt; \u0026lt;property name=\u0026#34;maxUploadSizePerFile\u0026#34; value=\u0026#34;1048576\u0026#34;/\u0026gt; \u0026lt;!--内存中最大的数据量，超过这个数据量，数据就要开始往硬盘中写了--\u0026gt; \u0026lt;property name=\u0026#34;maxInMemorySize\u0026#34; value=\u0026#34;4096\u0026#34;/\u0026gt; \u0026lt;!--临时目录，超过 maxInMemorySize 配置的大小后，数据开始往临时目录写，等全部上传完成后，再将数据合并到正式的文件上传目录--\u0026gt; \u0026lt;property name=\u0026#34;uploadTempDir\u0026#34; value=\u0026#34;file:///E:\\\\tmp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 不对静态进行拦截 --\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/**\u0026#34; location=\u0026#34;/\u0026#34;/\u0026gt;    controller  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  @RestController public class FileUploadController { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); @PostMapping(\u0026#34;/upload\u0026#34;) public String upload( MultipartFile file,HttpServletRequest req){ System.out.println(\u0026#34;------\u0026#34;); String format = sdf.format(new Date()); // System.out.println(\u0026#34;getContextPath:\u0026#34;+req.getContextPath()); // System.out.println(\u0026#34;getServletPath:\u0026#34;+req.getServletPath()); // System.out.println(\u0026#34;getRequestURL(请求全路径):\u0026#34;+req.getRequestURL()); // System.out.println(\u0026#34;getRequestURI:(请求路径)\u0026#34;+req.getRequestURI()); // System.out.println(\u0026#34;getServerName:(ip/域名)\u0026#34;+req.getServerName());  //System.out.println(\u0026#34;getRealPath:\u0026#34;+req.getRealPath());  String realPath = req.getRealPath(\u0026#34;/img\u0026#34;)+\u0026#34;/\u0026#34;+format+\u0026#34;/\u0026#34;; System.out.println(realPath); File folder = new File(realPath); if(!folder.exists()){ folder.mkdirs(); } String oldName = file.getOriginalFilename(); String newName = UUID.randomUUID().toString()+oldName.substring(oldName.lastIndexOf(\u0026#34;.\u0026#34;)); try { file.transferTo(new File(folder,newName)); String url = req.getScheme()+\u0026#34;://\u0026#34;+req.getServerName()+\u0026#34;:\u0026#34;+req.getServerPort()+\u0026#34;/img/\u0026#34;+format+\u0026#34;/\u0026#34;+newName; return url; } catch (IOException e) { e.printStackTrace(); } return \u0026#34;failed\u0026#34;; } }   StandardServletMultipartResolver做文件上传 这种文件上传方式，不需要依赖第三方 jar（主要是不需要添加 commons-fileupload 这个依赖），但是也不支持 Servlet3.0 之前的版本。\n springmvc配置  1 2  \u0026lt;bean class=\u0026#34;org.springframework.web.multipart.support.StandardServletMultipartResolver\u0026#34; id=\u0026#34;multipartResolver\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;    web.xml配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:spring-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 文件上传配置 --\u0026gt; \u0026lt;multipart-config\u0026gt; \u0026lt;!--文件保存的临时目录，这个目录系统不会主动创建--\u0026gt; \u0026lt;location\u0026gt;E:\\\\temp\u0026lt;/location\u0026gt; \u0026lt;!--上传的单个文件大小--\u0026gt; \u0026lt;max-file-size\u0026gt;1048576\u0026lt;/max-file-size\u0026gt; \u0026lt;!--上传的总文件大小--\u0026gt; \u0026lt;max-request-size\u0026gt;1048576\u0026lt;/max-request-size\u0026gt; \u0026lt;!--这个就是内存中保存的文件最大大小--\u0026gt; \u0026lt;file-size-threshold\u0026gt;4096\u0026lt;/file-size-threshold\u0026gt; \u0026lt;/multipart-config\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   多文件上传  key相同  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  //前端 \u0026lt;form action=\u0026#34;/upload2\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;files\u0026#34; multiple\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; //后台 @PostMapping(\u0026#34;/upload2\u0026#34;) public String upload2( MultipartFile [] files,HttpServletRequest req){ System.out.println(\u0026#34;------\u0026#34;); String format = sdf.format(new Date()); String realPath = req.getRealPath(\u0026#34;/img\u0026#34;)+\u0026#34;/\u0026#34;+format+\u0026#34;/\u0026#34;; System.out.println(realPath); File folder = new File(realPath); if(!folder.exists()){ folder.mkdirs(); } for (MultipartFile file : files){ String oldName = file.getOriginalFilename(); String newName = UUID.randomUUID().toString()+oldName.substring(oldName.lastIndexOf(\u0026#34;.\u0026#34;)); try { file.transferTo(new File(folder,newName)); String url = req.getScheme()+\u0026#34;://\u0026#34;+req.getServerName()+\u0026#34;:\u0026#34;+req.getServerPort()+\u0026#34;/img/\u0026#34;+format+\u0026#34;/\u0026#34;+newName; return url; } catch (IOException e) { e.printStackTrace(); } } return \u0026#34;failed\u0026#34;; }    key不相同  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  //前端 \u0026lt;form action=\u0026#34;/upload3\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file2\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; //后台 @PostMapping(\u0026#34;/upload3\u0026#34;) public void upload3( MultipartFile file1,MultipartFile file2,HttpServletRequest req){ System.out.println(\u0026#34;------\u0026#34;); String format = sdf.format(new Date()); String realPath = req.getRealPath(\u0026#34;/img\u0026#34;)+\u0026#34;/\u0026#34;+format+\u0026#34;/\u0026#34;; System.out.println(realPath); File folder = new File(realPath); if(!folder.exists()){ folder.mkdirs(); } try { String oldName = file1.getOriginalFilename(); String newName = UUID.randomUUID().toString()+oldName.substring(oldName.lastIndexOf(\u0026#34;.\u0026#34;)); file1.transferTo(new File(folder,newName)); String url = req.getScheme()+\u0026#34;://\u0026#34;+req.getServerName()+\u0026#34;:\u0026#34;+req.getServerPort()+\u0026#34;/img/\u0026#34;+format+\u0026#34;/\u0026#34;+newName; System.out.println(url); oldName = file2.getOriginalFilename(); newName = UUID.randomUUID().toString()+oldName.substring(oldName.lastIndexOf(\u0026#34;.\u0026#34;)); file2.transferTo(new File(folder,newName)); url = req.getScheme()+\u0026#34;://\u0026#34;+req.getServerName()+\u0026#34;:\u0026#34;+req.getServerPort()+\u0026#34;/img/\u0026#34;+format+\u0026#34;/\u0026#34;+newName; System.out.println(url); } catch (IOException e) { e.printStackTrace(); } }   10.拦截器 自定义拦截器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  @Component public class MyInterceptor1 implements HandlerInterceptor { /** * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行 * @param request * @param response * @param handler * @return * @throws Exception */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;MyInterceptor1:preHandle\u0026#34;); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;MyInterceptor1:postHandle\u0026#34;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;MyInterceptor1:afterCompletion\u0026#34;); } } @Component public class MyInterceptor2 implements HandlerInterceptor { /** * 这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行 * @param request * @param response * @param handler * @return * @throws Exception */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;MyInterceptor2:preHandle\u0026#34;); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;MyInterceptor2:postHandle\u0026#34;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;MyInterceptor2:afterCompletion\u0026#34;); } }   如果存在多个拦截器，拦截规则如下：\n preHandle 按拦截器定义顺序调用 postHandler 按拦截器定义逆序调用 afterCompletion 按拦截器定义逆序调用 postHandler 在拦截器链内所有拦截器返成功调用 afterCompletion 只有 preHandle 返回 true 才调用  springmvc配置文件 1 2 3 4 5 6 7 8 9 10  \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean=\u0026#34;com.dpf.interceptor.MyInterceptor1\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;bean=\u0026#34;com.dpf.interceptor.MyInterceptor2\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt;    \u0026lt;mvc:mapping path=\u0026quot;/**\u0026quot; /\u0026gt; 需要拦截的路径 \u0026lt;mvc:exclude-mapping path=\u0026quot;/login\u0026quot;/\u0026gt; 不拦截的路径  静态资源访问 在 SpringMVC 中，静态资源，默认都是被拦截的，例如 html、js、css、jpg、png、txt、pdf 等等，都是无法直接访问的。因为所有请求都被拦截了，所以，针对静态资源，我们要做额外处理，处理方式很简单，直接在 SpringMVC 的配置文件中，添加如下内容：\n1  \u0026lt;mvc:resources mapping=\u0026#34;/static/html/**\u0026#34; location=\u0026#34;/static/html/\u0026#34;/\u0026gt;   mapping 表示映射规则，也是拦截规则，就是说，如果请求地址是 /static/html 这样的格式的话，那么对应的资源就去 /static/html/ 这个目录下查找。\n在映射路径的定义中，最后是两个 *，这是一种 Ant 风格的路径匹配符号，一共有三个通配符：\n   通配符 含义     ** 匹配多层路径     | 匹配一层路径 ? | 匹配任意单个字符  一个比较原始的配置方式可能如下：\n1 2 3  \u0026lt;mvc:resources mapping=\u0026#34;/static/html/**\u0026#34; location=\u0026#34;/static/html/\u0026#34;/\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/static/js/**\u0026#34; location=\u0026#34;/static/js/\u0026#34;/\u0026gt; \u0026lt;mvc:resources mapping=\u0026#34;/static/css/**\u0026#34; location=\u0026#34;/static/css/\u0026#34;/\u0026gt;   但是，由于 ** 可以表示多级路径，所以，以上配置，我们可以进行简化：\n1  \u0026lt;mvc:resources mapping=\u0026#34;/**\u0026#34; location=\u0026#34;/\u0026#34;/\u0026gt;   ","title":"SpringMVC"},{"link":"https://blog.dpf114.top/posts/pythonbasestudy/","text":"1.基本语法 1 2 3 4 5 6  1.Python中严格区分大小写 2.Python中的每一行就是一条语句，每条语句以换行结束 3.Python中每一条语句不要太长(规范建议不要超过80个字符) 4.一条语句可以分多行编写，多行编写时语句后面以\\结尾 5.Python是缩进严格的语言，所以在Python中不要随便写缩进 6.在Python中用#表示注释，#后的内容都属于注释，注释的内容将会被解释器所忽略   1.字面量与变量 1 2 3 4  字面量：一个一个的值，即字面的值，程序中可直接使用 变量：变量可以直接保存字面量，并且保存的字面量是不定的 1.Python中使用变量，不需要直接声明，直接为变量赋值即可 2.Python是一个动态类型的语言，可以为变量赋任意类型的值，也可以任意修改变量的值   2.标识符 1 2 3 4 5 6 7 8  在Python中所有可以自主命名的内容都属于标识符 比如：变量名、函数名、类名 命名规则： 1.标识符中可以含有字母、数字、‘_’，但是不能以数字开头 2.标识符不能含有Python中的关键字和保留字 3.命名规范： 1）下划线命名法：所有字母小写，单词之间用‘_’分割 2）帕斯卡命名法（大驼峰命名法）：首字母大写，每个单词开头的字母大写，其余字母小写   3.数值：整数(都是int型)、浮点数、复数   Python中整数大小没有限制，可以是一个无限大的数\n  如果数字的长度过大，可以使用下划线分隔符\n  对浮点数计算时可能会得到一个不精确的结果\n  4.字符串:用引号引起来的字符   引号不能混合使用\n  引号之间不能嵌套\n  单个引号不能跨行使用(即引号开始结束都必须在同一行)\n  三重引号表示一个长字符串，可以换行(换行不需要)，保留原格式\n  字符串不能和其他类型相加\n  占位符\n  1 2 3 4 5 6 7 8 9 10 11  # 在创建字符串时，可以在字符串中指定占位符 # %s 在字符串中表示任意字符 # %f 浮点数占位符 # %d 整数占位符 b = \u0026#39;Hello %s\u0026#39;%\u0026#39;孙悟空\u0026#39; b = \u0026#39;hello %s 你好 %s\u0026#39;%(\u0026#39;tom\u0026#39;,\u0026#39;孙悟空\u0026#39;) b = \u0026#39;hello %3.5s\u0026#39;%\u0026#39;abcdefg\u0026#39; # %3.5s字符串的长度限制在3-5之间 b = \u0026#39;hello %s\u0026#39;%123.456 b = \u0026#39;hello %.2f\u0026#39;%123.456 b = \u0026#39;hello %d\u0026#39;%123.95 b = \u0026#39;呵呵\u0026#39;    字符串前加f格式化字符串  1 2 3 4 5 6  # 格式化字符串，可以通过在字符串前添加一个f来创建一个格式化字符串 # 在格式化字符串中可以直接嵌入变量 a = \u0026#39;fdsf\u0026#39; b = \u0026#39;432432\u0026#39; c = f\u0026#39;hello {a} {b}\u0026#39;    格式化字符串四种方式  1 2 3 4 5  name = \u0026#39;pikachues\u0026#39; print(\u0026#39;欢迎\u0026#39;+name+\u0026#39;光临！\u0026#39;) print(\u0026#39;欢迎\u0026#39;,name,\u0026#39;光临！\u0026#39;) print(\u0026#39;欢迎%s\u0026#39;%name) print(f\u0026#39;欢迎{name}光临！\u0026#39;)    复制字符串  1 2 3 4 5  # 字符串的复制（将字符串和数字相乘） a = \u0026#39;abc\u0026#39; # * 在语言中表示乘法 # 如果将字符串和数字相乘，则解释器会将字符串重复指定的次数并返回 a = a * 20   5.其他类型 1.布尔值(bool):实际上属于整数  True相当于1 False相当于0  2.None(空值):专门用来表示不存在 6.类型相关 1.类型检查 1 2 3 4 5 6 7 8 9 10  # type()用来检查值的类型 # 该函数会将检查的结果作为返回值返回，可以通过变量来接收函数的返回值 c = type(\u0026#39;123\u0026#39;) c = type(a) # print(type(b)) print(type(1)) # \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; print(type(1.5)) # \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; print(type(True)) # \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; print(type(\u0026#39;hello\u0026#39;)) # \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; print(type(None)) # \u0026lt;class \u0026#39;NoneType\u0026#39;\u0026gt;   2.类型转换 类型转换四个函数 int() float() str() bool()\n int() 可以用来将其他的对象转换为整型   规则： 布尔值：True -\u0026gt; 1 False -\u0026gt; 0 浮点数：直接取整，省略小数点后的内容 字符串：合法的整数字符串，直接转换为对应的数字 如果不是一个合法的整数字符串，则报错 ValueError: invalid literal for int() with base 10: \u0026lsquo;11.5\u0026rsquo; 对于其他不可转换为整型的对象，直接抛出异常 ValueError\n   float() 和 int()基本一致，不同的是它会将对象转换为浮点数\n  str() 可以将对象转换为字符串\n   True -\u0026gt; \u0026lsquo;True\u0026rsquo; False -\u0026gt; \u0026lsquo;False\u0026rsquo;\n123 -\u0026gt; \u0026lsquo;123\u0026rsquo;\n  bool() 可以将对象转换为布尔值，任何对象都可以转换为布尔值   规则：对于所有表示空性的对象都会转换为False，其余的转换为True 哪些表示的空性：0 、 None 、 '' 。。。\n 7. 算术运算符  加法运算符（如果是两个字符串之间进行加法运算，则会进行拼串操作）   减法运算符    乘法运算符（如果将字符串和数字相乘，则会对字符串进行复制操作，将字符串重复指定次数）\n  / 除法运算符，运算时结果总会返回一个浮点类型\n  // 整除，只会保留计算后的整数位，总会返回一个整型\n  ** 幂运算，求一个值的几次幂\n2 ** 2 = 4\r16 ** 0.5 = 4\r  % 取模，求两个数相除的余数\n  8.赋值运算符   = 可以将等号右侧的值赋值给等号左侧的变量\n  a += 5 相当于 a = a + 5\n  a -= 5 相当于 a = a - 5\n  a *= 5 相当于 a = a * 5\n  a**=5 相当于 a = a ** 5\n  a /= 5 相当于 a = a / 5\n  a //= 5 相当于 a = a // 5\n  a %= 5 相当于 a = a % 5\n  9.关系运算符  关系运算符用来比较两个值之间的关系，总会返回一个布尔值\n如果关系成立，返回True，否则返回False\n   ' \u0026gt;' 比较左侧值是否大于右侧值\n  \u0026lsquo;\u0026gt;=\u0026rsquo; 比较左侧的值是否大于或等于右侧的值\n  \u0026lt; 比较左侧值是否小于右侧值\n  \u0026lt;= 比较左侧的值是否小于或等于右侧的值\n  == 比较两个对象的值是否相等\n  != 比较两个对象的值是否不相等 相等和不等比较的是对象的值，而不是id\n  is 比较两个对象是否是同一个对象，比较的是对象的id\n  is not 比较两个对象是否不是同一个对象，比较的是对象的id\n  字符串相比较时实际上比较的是Unicode编码\n10.逻辑运算符  not：逻辑非   返回的都是bool值\n  and：逻辑与(一假则假)   考虑短路现象\n非布尔值运算时：当做布尔值运算返回原值\n例.\nresult = 1 and 2 #result=2\nresult = 1 or 2 #result = 1\n  or：逻辑或(一真则真)   考虑短路现象\n非布尔值运算时：当做布尔值运算返回原值\n 2.流程控制 代码块 如果要编写代码块，语句就不能紧随在:后边，而是要写在下一行，代码块以缩进开始，直到代码恢复到之前的缩进级别时结束。\ninput函数 从键盘获取用户输入。\n1 2 3 4 5 6 7 8 9 10  a = intput(\u0026#34;请输入\u0026#34;) b = input() age = int(input(\u0026#34;请输入年龄\u0026#34;)) if age \u0026lt;=10: print(\u0026#34;小于等于10\u0026#34;) elif age \u0026gt;10 and age \u0026lt;=20: print(\u0026#34;10-20\u0026#34;) else: print(\u0026#34;大于20\u0026#34;)   用sublime可能不起作用需要下载插件:http://packagecontrol.cn/installation\n依次点击 Preferences—Key Buildings，输入以下内容，然后保存，设置按键 F5（可以随意修改）为运行程序快捷键\n1 2 3 4 5 6 7 8 9  [ { \u0026#34;keys\u0026#34;: [\u0026#34;f5\u0026#34;], \u0026#34;caption\u0026#34;: \u0026#34;SublimeREPL:Python\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;run_existing_window_command\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;repl_python_run\u0026#34;, \u0026#34;file\u0026#34;: \u0026#34;config/Python/Main.sublime-menu\u0026#34; } }, ]   条件控制if..else.. 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # if ..else if 判断条件： 执行语句…… else： 执行语句…… # if..else if.. if 判断条件： 执行语句.. elif 判断条件： 执行语句... else: 执行语句...   举例 1 2 3 4 5 6 7  # 判断输入的年份是闰年还是平年 year = int(input(\u0026#34;请输入你要判断的年份\u0026#34;)) if year % 4 ==0 and year % 100 !=0 or year % 400 ==0: print(year,\u0026#34;是闰年\u0026#34;) else: print(year,\u0026#34;是平年\u0026#34;)   while循环 1 2 3 4  while 判断条件： 代码块 else: 代码块   举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  # 求100以内所有的奇数之和 i = 0 result = 0 while i\u0026lt;100: i += 1 if i % 2 !=0: result +=i print(result) # 获取用户输入的任意数，判断其是否是质数 num = int(input(\u0026#34;输入任意整数\u0026#34;)) i = 2 falg = True while i \u0026lt; num: if num % 2 == 0: falg = False break if falg: print(num,\u0026#34;是质数\u0026#34;) else: print(num,\u0026#34;不是是质数\u0026#34;) # 99乘法表 i = 1 while i \u0026lt; 10: j = 1 while j \u0026lt;= i: print(f\u0026#34;{j}*{i}={i*j} \u0026#34;,end=\u0026#34;\u0026#34;) j += 1 print() i += 1 # 输出100以内的质数 n = 2 while n \u0026lt;100: i = 2 if n == 2: print(n,end=\u0026#39; \u0026#39;) falg = False while i \u0026lt; n: if n % 2 != 0: falg = True break i += 1 if falg: print(n,end=\u0026#34; \u0026#34;) n += 1 # 输出100000以内的质数(优化) from time import * begin = time() i = 2 while i \u0026lt;= 100000: flag = True j = 2 while j \u0026lt;= i ** 0.5: if i % j == 0: flag = False # 一旦进入判断，则证明i一定不是质数，此时内层循环没有继续执行的必要 # 使用break来退出内层的循环 break j += 1 if flag : # print(i)  # pass为空语句 pass i += 1 # 获取程序结束的时间 end = time() # 计算程序执行的时间 print(\u0026#34;程序执行花费了：\u0026#34;,end - begin , \u0026#34;秒\u0026#34;)   break与continue break跳过整个循环(结束循环)，continue跳过当次循环\n 经过一段时间的学习我发现python与其他语言的基础语法基本差不多，不同的是python没有i++,++i这一个运算\n ","title":"Python基础学习"},{"link":"https://blog.dpf114.top/posts/frpinnetpass/","text":"前言 最近学习微信公众号，微信公众号测试时需要内网穿透，开始时使用ngrock(第一天用的挺稳)，第二天连接ngrock时发现总是不能连接，于是去找了其他内网穿透工具，但发现其他内网穿透工具也一样(要么是收费，要么不稳定)，于是想自己代建一个内网穿透工具。\n实现 准备  公网服务器1台(linux) 已经备案的域名一个(已经解析到你上面的服务器)  安装frp 1.linux安装  下载:https://github.com/fatedier/frp/releases  1  sudo wget https://github.com/fatedier/frp/releases/download/v0.31.2/frp_0.31.2_linux_amd64.tar.gz    解压并改名  1 2  sudo tar xzvf frp_0.31.2_linux_amd64.tar.gz sudo mv frp_0.31.2_linux_amd64 frp    进入解压目录  1  cd frp   frps、frps.ini这个两个是服务端文件，frpc、frpc.ini这两个是客户端文件\n 配置服务端vim ./frps.ini  1 2 3 4 5  [common] bind_port = 7000 #与客户端绑定的进行通信的端口 vhost_http_port = 80 #访问客户端web服务自定义的端口号 vhost_https_port = 443 token = 12345678 #秘钥可以自己修改,与后面客户端配置一致    启动服务端  1 2 3 4  # 临时启动 ./frps -c ./frps.ini # 后台启动 nohup ./frps -c ./frps.ini \u0026amp;   2.windows安装  下载  解压后如下图  打开frpc.ini进行配置  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [common] server_addr = xxx.xxx.xx.xx #你配置的服务器地址  server_port = 7000 token = 12345678\t#与前面服务器配置的token一致 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [web] type = http local_ip = 127.0.0.1 local_port = 8080\tcustom_domains = www.xxxx.com #你自己的域名    启动  1  ./frpc -c ./frpc.ini   3.测试 用tomcat(8080端口)随便部署一个项目,先本地访问再用域名访问 ","title":"frp实现内网穿透"}],"tags":[{"link":"https://blog.dpf114.top/tags/git/","name":"Git","slug":"Git"},{"link":"https://blog.dpf114.top/tags/http/","name":"HTTP","slug":"HTTP"},{"link":"https://blog.dpf114.top/tags/https/","name":"HTTPS","slug":"HTTPS"},{"link":"https://blog.dpf114.top/tags/htts/","name":"HTTS","slug":"HTTS"},{"link":"https://blog.dpf114.top/tags/jwt/","name":"jwt","slug":"jwt"},{"link":"https://blog.dpf114.top/tags/linux/","name":"Linux","slug":"Linux"},{"link":"https://blog.dpf114.top/tags/nginx/","name":"Nginx","slug":"Nginx"},{"link":"https://blog.dpf114.top/tags/python%E5%9F%BA%E7%A1%80/","name":"Python基础","slug":"Python基础"},{"link":"https://blog.dpf114.top/tags/springmvc/","name":"SpringMvc","slug":"SpringMvc"},{"link":"https://blog.dpf114.top/tags/%E4%B8%B4%E6%97%B6cookies/","name":"临时cookies","slug":"临时cookies"},{"link":"https://blog.dpf114.top/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/","name":"局域网","slug":"局域网"}]}